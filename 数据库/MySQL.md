详细了解MySql索引相关(日常用的多，很重要)  

InnoDB引擎支持两种索引,一种是B+树索引，另一个是哈希索引。  

InnoDB存储引擎支持的哈希索引是自适应的，INNoDb存储引擎会根据表的使用情况自动为表生成哈希索引
，不能人为干预是否在一张表中生成哈希索引。

explain分析sql时需要关注哪几个参数？
select_type:simple    简单查询还是联表查询
table:city       表名
type: ref,all,index,const    走索引还是走全表扫描
key: primary  使用的索引名称


#### mysql默认引擎为innodb，innodb默认使用行锁，而行锁是基于索引的，因此要想加上行锁，在加锁时必须命中索引，否则将使用表锁

### 1. Where子句过滤指定的是行而不是分组，事实上，Where没有分组的概念。那么不能用where用什么呢？
答案是Having子句。目前为止所学过的所有类型的where子句都可以用having来替代
having和where的区别：where在数据分组前对行进行过滤，having在数据分组后进行过滤

### 2. Union会从查询结果集中自动去除重复行，这是union的默认行为，如果需要可以用union all
来返回所有匹配的行而不进行去重。
union与where：union all为union的一种形式，如果确实需要每个条件的匹配行全部出现(包括重复行)
，则必须使用union all而不是where
在用union组合查询时，只能使用一条order by子句，它必须出现在最后一条select语句之后。
对于结果集，不存在用一种方式排序一部分，然后用另一部分排序另一部分的情况，
因此不允许使用多条order by子句。 因为union只是将所有结果集合成一个结果集，自然而然无论
有多少个union连接，都只能有一个order by子句来排序
利用union，可以把多条查询的结果作为一个结果集返回，这个结果集可以包含重复也可以不包含重复

### 3. Select查询结果按指定顺序排序:
```
SELECT
	*
FROM
	uc_user_identifier
WHERE
	uc_user_id = 4
ORDER BY
	FIELD(
		identifier_type,
		"EMAIL",
		"MOBILE"
	)
```
  	
### 4. Mysql 5.6 升级到 5.7 出现 groupBy 的问题
```
select @@GLOBAL.sql_mode;
select @@SESSION.sql_mode;
```
将结果中 ONLY_FULL_GROUP_BY去掉并保存即可解决。

### 5. 隔离级别: 在事务中为保证并发数据读写的正确性而提出的定义

事务就是由一组sql语句作为一个不可分割的单元被执行
隔离级别是针对事务来说的，mysql中只有innoDb引擎支持事务，而innoDB的隔离级别是基于 MVCC（Multi-Versioning Concurrency Control）和锁的复合实现
>1. Read uncommitted(读未提交)，就是一个事务能够看到其他事务尚未提交的修改，这是最低的隔离水平，允许脏读出现。

>2. Read committed(读已提交),
事务能够看到的数据都是其他事务已经提交的修改，也就是保证不会看到任何中间性状态，当然脏读也不会出现。读已提交仍然是比较低级别的隔离，并不保证再次读取时能够获取同样的数据，也就是允许其他事务并发修改数据，允许不可重复读和幻象读（Phantom Read）出现 

>3. Repeatable reads(可重复读),保证同一个事务中多次读取的数据是一致的，这是 MySQL InnoDB 引擎的默认隔离级别，但是和一些其他数据库实现不同的是，可以简单认为 MySQL 在可重复读级别不会出现幻象读  

>4. Serializable(串行化),并发事务之间是串行化的，通常意味着读取需要获取共享读锁，更新需要获取排他写锁，如果 SQL 使用 WHERE 语句，还会获取区间锁（MySQL 以 GAP 
锁形式实现，可重复读级别中默认也会使用），这是最高的隔离级别  

*注意*:
(1)脏读:
(2)幻读:

随着隔离级别从低到高，竞争性（Contention）逐渐增强，随之而来的代价是性能和扩展性的下降

至于悲观锁和乐观锁，也并不是 MySQL 或者数据库中独有的概念，而是并发编程的基本概念。主要区别在于，操作共享数据时，“悲观锁”即认为数据出现冲突的可能性更大，而“乐观锁”则是认为大部分情况不会出现冲突，进而决定是否采取排他性措施。

反映到 MySQL 数据库应用开发中，悲观锁一般就是利用类似 SELECT … FOR UPDATE 这样的语句，对数据加锁，避免其他事务意外修改数据。乐观锁则与 Java 并发包中的 AtomicFieldUpdater 类似，也是利用 CAS 机制，并不会对数据加锁，而是通过对比数据的时间戳或者版本号，来实现乐观锁需要的版本判断。我认为前面提到的 MVCC，其本质就可以看作是种乐观锁机制，而排他性的读写锁、双阶段锁等则是悲观锁的实现。

### 6. innodb_lock_wait_timeout 和 lock_wait_timeout 这两个参数的区别？
* 分别是 InnoDB等行锁，和 Server层等表锁

### 7. binlog有几种格式？分别是哪几种？
* binlog 有两种格式，一种是 statement，一种是 row。第三种格式，叫作 mixed，其实它就是前两种格式的混合。
* 当 binlog_format=statement 时，binlog 里面记录的就是 SQL 语句的原文
* 当 binlog_format=‘row’时，记录binlog是以event为单位的。row 格式的缺点是，很占空间。比如你用一个 delete 语句删掉 10 万行数据，
用 statement 的话就是一个 SQL 语句被记录到 binlog 中，占用几十个字节的空间。但如果用 row 格式的 binlog，
就要把这 10 万条记录都写到 binlog 中。这样做，不仅会占用更大的空间，同时写 binlog 也要耗费 IO 资源，
影响执行速度。
* 当 binlog_format=‘mixed’时，通常情况下是记录statement格式的binlog，但是如果有些sql语句mysql认为会发生歧义，则会补充记录row格式的binlog，

场景：
当执行如下sql时，三种格式的binlog会发生如下:
```
delete from t where a >= 4 and t_modified <= '2018-11-10' limit 1;
```
statement格式记录这个sql，会产生一个warning，原因是语句中包含limit子句，这个命令可能是unsafe的。  
什么情况下会发生unsafe事件呢？  
如果此sql走的是 a 的索引，那么会根据索引 a 找到第一个满足条件的行，所以删除的是a=4这条记录,
如果使用的是 t_modified 索引，那么删除的就是 t_modified='2018-11-09’也就是 a=5 这一行。
所以当主库和备库执行sql选择的索引不同就会发生unsafe  

### 8.为什么越来越多的场景要求把 MySQL 的 binlog 格式设置成 row？
因为设置为 row 格式对于恢复数据十分方便。分别从delete,insert，update语句说恢复方式:
* delete: 即使执行的是delete语句，row 格式的 binlog 也会把被删掉的行的整行信息保存起来。
所以，如果执行 delete 语句后，发现删错了数据，可以直接把 binlog 中记录的 delete 语句转成 insert，
把被删除的数据再insert回去就可以恢复了。
* insert: 如果误执行了insert语句时，binlog会记录所有字段信息，这些信息可以精确定位到刚刚插入的那行数据。这时可以直接把insert语句转为delete语句，
删掉就可以了
* update: 如果误执行了 update 语句，binlog 里面会记录修改前 整行的数据 和 修改后的整行数据，
只需要把这个 event 前后的两行信息对调一下，再去数据库里面执行第一条，就可以恢复到update之前的状态了  

### 9. MySQL是如何解决主主同步的循环复制问题的？
* 主主同步，指的是主A和主B是互为主备关系，是两条线相连的。
循环复制，指的是A把B当作从机，

### 10.说一下索引常见的3种模型？
* 索引的使命就是为了提高数据查询效率，就像书的目录一样。索引就是数据库表的目录  
一本 500 页的书，如果想快速找到其中的某一个知识点，
在不借助目录的情况下，估计要找一会。同样，对于数据库的表而言，索引其实就是它的“目录”。

* 哈希表:用拉链法解决哈希冲突，哈希表不是有序的，所以做区间查询速度很慢。哈希表这种结构适用于只有等值查询的场景，比如 Memcached 及其他一些 NoSQL 引擎。

* 有序数组:有序数组在等值查询和范围查询场景中的性能就都非常优秀。查询单条数据用二分法，查询区间用二分法先确定左边界，
然后向右遍历循环查找。缺点是更新数据比如插入数据时，需要挪动后面所有记录，成本太高。有序数组索引只适用于静态存储引擎，
比如你要保存的是 2017 年某个城市的所有人口信息，这类不会再修改的数据。

* 搜索树:在二叉树中查询时间复杂度为O(log(N)) ，为了保证二叉树的平衡性，更新时时间复杂度也是O(log(N))

### 11.按不同类型对索引分类？
* 根据叶子节点的内容，索引类型分为主键索引和非主键索引。主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引
非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引

### 12.基于主键索引和普通索引的查询有什么区别？
* 主键索引查询: 如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；
* 普通索引查询: 如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，
得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。也就是说，基于非主键索引的查询需要多扫描一棵索引树。
因此，我们在应用中应该尽量使用主键查询。   

innodb中对主键索引的存储方式为聚簇索引，即主键索引key值为主键值，value为整行数据

普通索引key值为普通索引值，value为对应的主键值 

### 13.用自增主键为什么比用业务主键效率高？

一个数据页满了，按照B+Tree算法，新增加一个数据页，叫做页分裂，会导致性能下降。空间利用率降低大概50%。当相邻的两个数据页利用率很低的时候会做数据页合并，合并的过程是分裂过程的逆过程。

B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，如果插入新的行 ID 值为 700，则只需要在 R5 的记录后面插入一个新记录。
如果新插入的 ID 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。而更糟的情况是，
如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。
这个过程称为页分裂。在这种情况下，性能自然会受影响。除了性能外，页分裂操作还影响数据页的利用率。
原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。当然有分裂就有合并。
当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。

B+ 树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。  

索引的实现由存储引擎来决定，InnoDB使用B+树（N叉树，比如1200叉树），把整颗树的高度维持在很小的范围内，
同时在内存里缓存前面若干层的节点，可以极大地降低访问磁盘的次数，提高读的效率。

也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。

从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？
由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，
而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节。显然，主键长度越小，
普通索引的叶子节点就越小，普通索引占用的空间也就越小。所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。

### 14.什么场景适合用业务字段直接做主键？
* 有些业务的场景需求是这样的：只有一个索引；该索引必须是唯一索引。这就是典型的 KV 场景。由于没有其他索引，
所以也就不用考虑其他索引的叶子节点大小的问题。这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则，
直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。

### 15.select * 和select具体字段有什么区别？
select *要读和拷贝更多列到server,还要发送更多列给客户端，所以还是select id更快的。

### 16.通过两个 alter 语句重建索引 k，以及通过两个 alter 语句重建主键索引是否合理？
重建普通索引:  
```
alter table T drop index k;
alter table T add index(k);
```
重建主键索引:
```
alter table T drop primary key;
alter table T add primary key(id);
```
如果删除并新建主键索引，会同时去修改普通索引对应的主键索引，性能消耗比较大。
删除重建普通索引貌似影响不大，不过要注意在业务低谷期操作，避免影响业务。

如果有同时删除普通索引和主键索引的需求，需要注意顺序：
顺序应是先删除k列索引，主键索引。然后再创建主键索引和k列索引。

1. 直接删掉主键索引是不好的，它会使得所有的二级索引都失效，并且会用ROWID来作主键索引；
2. 看到mysql官方文档写了三种措施，第一个是整个数据库迁移，先dump出来再重建表（这个一般只适合离线的业务来做）；
第二个是用空的alter操作，比如ALTER TABLE t1 ENGINE = InnoDB;这样子就会原地重建表结构（真的吗？）；
第三个是用repaire table，不过这个是由存储引擎决定支不支持的（innodb就不行）。

为什么要重建索引？索引可能因为删除，或者页分裂等原因，导致数据页有空洞，
重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。

删除数据的同时索引也删除了，但是引起了页里面的空洞，alter table T engine=InnoDB是重建索引去掉空洞的操作

重建索引 k 的做法是合理的，可以达到省空间的目的。但是，重建主键的过程不合理。不论是删除主键还是创建主键，
都会将整个表重建。所以连着执行这两个语句的话，第一个语句就白做了。这两个语句，你可以用这个语句代替 ： 
```
alter table T engine=InnoDB。
```

实例：今天这个 alter table T engine=InnoDB 让我想到了我们线上的一个表, 记录日志用的, 会定期删除过早之前的数据.
最后这个表实际内容的大小才10G, 而他的索引却有30G. 在阿里云控制面板上看,就是占了40G空间. 这可花的是真金白银啊.
后来了解到是 InnoDB 这种引擎导致的,虽然删除了表的部分记录,但是它的索引还在, 并未释放.只能是重新建表才能重建索引.

### 17.没有主键的表，有一个普通索引。怎么回表？
没有主键的表，innodb会给默认创建一个Rowid做主键

### 18.N叉树”的N值在MySQL中是可以被人工调整的么？
5.6以后可以通过page大小来间接控制  
数据页调整后，如果数据页太小层数会太深，数据页太大，加载到内存的时间和单个数据页查询时间会提高，需要达到平衡才行  
默认情况下，表空间中的页大小都为 16KB，当然也可以通过改变 innodb_page_size 选项对默认大小进行修改，需要注意的是不同的页大小最终也会导致区大小的不同  

1， 通过改变key值来调整
N叉树中非叶子节点存放的是索引信息，索引包含Key和Point指针。Point指针固定为6个字节，假如Key为10个字节，那么单个索引就是16个字节。如果B+树中页大小为16K，那么一个页就可以存储1024个索引，此时N就等于1024。我们通过改变Key的大小，就可以改变N的值
2， 改变页的大小
页越大，一页存放的索引就越多，N就越大。


从普通索引查询到主键索引，然后回到主键索引树搜索的过程，我们称为回表

### 19.什么是覆盖索引？
如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，
不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。
由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。

也就是说。索引中如何有你要查询的数据，就称为覆盖索引

覆盖索引不能只覆盖要查询的列，同时必须将WHERE后面的查询条件的列都覆盖，因为覆盖索引的目的就是”不回表“，
所以只有索引包含了where条件部分和select返回部分的所有字段，才能实现这个目的

### 20.什么是最左前缀原则？
B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录。也就是说，如何用两个字段建立了联合索引，
这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。  

### 21.什么是索引下推？
在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。

而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，
对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

### 22.下面两条语句有什么区别，为什么都提倡使用2:
```
1.select * from T where k in(1,2,3,4,5)
2.select * from T where k between 1 and 5
```
* 第一个要搜索5次,算是等值匹配
* 第二个搜索一次(因为B+树叶子节点是顺序存储的,其叶子节点增加了范围查询)。第二个sql中mysql会认为是一个连续的范围，
通过一次查找找到开始位置之后，继续往后遍历即可。而between 1 and 5 是范围查询，每个叶子节点都有一个额外指针，
指向下一个叶子结点，且他们的值都是有序的，直接遍历叶子结点的链表就可以了。
两个sql都是回表5次

### 23.数据量很大的时候，二级索引比主键索引更快”，这个结论什么情况下成立？
* 只有在使用覆盖索引时才成立，非覆盖索引还是要回表查询。

### 24.MySQL中锁分为哪三类？
根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类。  
* 全局锁：全局锁就是对整个数据库实例加锁，命令是 Flush tables with read lock (FTWRL)，
命令执行后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。
使用场景：全库逻辑备份。也就是把整库每个表都 select 出来存成文本。

全局备份的方法：官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数–single-transaction 的时候，
导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。

一致性读是好，但前提是引擎要支持这个隔离级别。比如，对于 MyISAM 这种不支持事务的引擎，如果备份过程中有更新，
总是只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用 FTWRL 命令了。

所以，single-transaction 方法只适用于所有的表使用事务引擎的库。如果有的表使用了不支持事务的引擎，那么备份就只能通过 FTWRL 方法。

* 表级锁MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。

表锁的语法是 lock tables … read/write。与 FTWRL 类似，可以用 unlock tables 主动释放锁，
也可以在客户端断开的时候自动释放。需要注意，lock tables 语法除了会限制别的线程的读写外，
也限定了本线程接下来的操作对象。举个例子, 如果在某个线程 A 中执行 lock tables t1 read, t2 write; 
这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，
也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。

另一类表级的锁是 MDL（metadata lock)。MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，
保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，
删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。因此，在 MySQL 5.5 版本中引入了 MDL，
当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。读锁之间不互斥，
因此你可以有多个线程同时对一张表增删改查。读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。
因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

### 25.在 InnoDB 事务中，什么是行锁的两阶段锁协议？以及知道了两阶段锁协议我们如何优化事务中使用的行锁？
* 行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。

启示：如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放






























