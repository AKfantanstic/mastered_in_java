
1. redis简介: redis是一个内存数据库，读写速度比较快，所以多用于做缓存。此外，redis支持事务，持久化，lua脚本，集群部署  

2. 为什么要用redis:
(1) 缓解数据库压力  
(2) 

3. 为什么不用map或者guava做缓存？
map和guava实现的是本地缓存，生命周期随着jvm的销毁而结束。在分布式架构中，多个实例每个实例单独持有一份缓存，无法保证缓存一致性

而redis或memCached属于分布式缓存，在分布式架构的多个实例下，可以共用一份缓存，可以保证缓存一致性。缺点是需要保证缓存的高可用  


### 3.redis有哪几种数据类型？字符串最大不能超过多少？
* redis的key只支持String，value支持5种类型: 字符串（String）、哈希（hash)、列表（list)、集合(set)、有序集合(zset)
还有HyperLogLog、流、地理坐标等
* 512MB

### 4.redis为什么快？
* 纯内存访问
* 单线程架构避免了线程上下文切换带来的资源损耗
* 使用基于事件的IO多路复用模型

### 5. redis默认分多少个数据库？
* 16个，从0到15
 
### 6.Redis和Memcache的区别？
* memcached只支持简单的k/v结构。key和value只支持字符串。而redis支持更多类型的存储结构类型


### 7. redis持久化的几种方式？
* RDB(Redis DataBase): RDB持久化是把当前进程数据生成快照以二进制的方式写入磁盘的过程
RDB 的持久化是如何触发的？
（1）手动触发:
save :阻塞当前 Redis 服务器，直到 RDB 过程完成为止，如果数据比较大的话，会造成长时间的阻塞，线上不建议。
bgsave:redis 进程执行 fork 操作创作子进程，持久化由子进程负责，完成后自动结束，阻塞只发生在fork阶段，
一般时间很短。
（2）自动触发：
savexsecends n: 表示在x秒内，至少有n个键发生变化，就会触发RDB持久化。也就是说满足了条件就会触发持久化。
flushall:主从同步触发  
2.RDB的优点？  
rdb是一个紧凑的二进制文件，代表Redis在某个时间点上的数据快照。  
适合于备份，全量复制的场景，对于灾难恢复非常有用。  
Redis加载RDB恢复数据的速度远快于AOF方式。  
3.RDB的缺点？  
RDB没法做到实时的持久化。中途意外终止，会丢失一段时间内的数据。  
RDB需要fork创建子进程，属于重量级操作，可能导致Redis卡顿若干秒。  

* AOF(append only file): 为了解决 rdb 不能实时持久化的问题，以独立的日志方式记录把每次命令记录到 aof 文件中。
AOF工作流程？

（1）所有写入命令追加到aof_buf缓冲区。

（2）AOF缓冲区根据对应的策略向硬盘做同步操作。

（3）随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。

（4）当redis服务器重启时，可以加载AOF文件进行数据恢复。

4.为什么AOF要先把命令追加到缓存区(aof_buf)中？

Redis使用单线程响应命令，如果每次写入文件命令都直接追加到硬盘，性能就会取决于硬盘的负载。如果使用缓冲区，redis提供多种缓冲区策略，在性能和安全性方面做出平衡。

5.AOF持久化如何触发的？

（1）自动触发：满足设置的策略和满足重写触发。
always 命令写入aof_buf后调用系统fsync操作同步到aof文件，fsync完成后线程返回
every sec 命令写入aof_buf后调用系统write操作，write完成后线程返回。fsync同步文件操作由专门线程每秒调用一次
no 命令写入aof_bug后调用系统write操作，不对aof文件做fsync同步，同步硬盘操作由操作系统负责，通常同步周期最长30秒
（2）手动触发：（执行命令）

bgrewriteaof 

6.AOF优点？

AOF提供了3种保存策略：每秒保存、跟系统策略、每次操作保存。实时性比较高，一般来说会选择每秒保存，因此意外发生时顶多失去一秒的数据。
文件追加写形式，所以文件很少有损坏问题，如最后意外发生少写数据，可通过redis-check-aof工具修复。

AOF由于是文本形式，直接采用协议格式，避免二次处理开销，另外对于修改也比较灵活。

7.AOF缺点？

AOF文件要比RDB文件大。
AOF冷备没RDB迅速。

由于执行频率比较高，所以负载高时，性能没有RDB好。


* 混合持久化:  
一般来说我们的线上都会采取混合持久化。redis4.0以后添加了新的混合持久化方式。  
1.优点：  
在快速加载的同时，避免了丢失过更多的数据。  
2.缺点：  
由于混合了两种格式，所以可读性差。  
兼容性，需要4.0以后才支持。  







##### 缓存淘汰策略:
1. FIFO(first in first out) 先进先出策略。使得最先进入的数据被淘汰掉
应用场景: 在实时性比较高的要求下，需要经常访问最新的数据  
2. LRU(Least Recently Used) 最近最久未使用策略。优先淘汰最久未使用的数据  
应用场景:需要保存内存中的数据都是热点数据，保证缓存命中率  
3. LFU(Least Frequently Used) 最不经常使用策略。淘汰一段时间内使用次数最少的数据  

LRU和LFU的区别:  
LRU是淘汰最长时间未被使用的数据，LFU是淘汰一定时间内被访问次数最少的数据  

##### 引入缓存带来的问题:
1. 缓存穿透:用户对某些一定不在缓存中的数据进行请求，则这些请求会直接到达数据库，造成缓存穿透  
解决方案:  
(1)对这类请求进行过滤  
(2)对这些不存在的数据缓存一个空数据  

2. 缓存雪崩:指的是缓存数据大面积失效，叫雪崩  
原因:  
(1)数据没有被加载到缓存中  
(2) 缓存在同一时间大量失效  
(3)缓存服务器宕机  
在有缓存起作用的系统中，缓存分担了很大一部分请求，当雪崩发生后，所有请求直接打到数据库，会导致数据库崩溃  
解决方案:  
(1)合理设置缓存过期时间，最好是随机数，这样避免同一时间大面积失效  
(2) 为防止单点故障，可以使用分布式缓存，保证可用性  
(3) 进行缓存预热，避免系统刚启动不久还未将大量数据缓存导致的缓存雪崩  

3. 缓存一致性:在数据更新时缓存必须同时被更新  
解决方案:  
(1) 在更新数据时更新缓存  
(2) 读缓存之前先判断是否为最新缓存，如果不是最新的则更新  

保证缓存一致性需要付出很大代价，所以缓存中最好放点对一致性要求不高的东西。  

##### 正向代理和反向代理:
总结起来就是正向代理隐藏真实客户端，反向代理隐藏真实服务端  

正向代理，代理的是客户端,典型应用是 科学上网。客户端无法上google，客户端请求代理客户端，代理客户端请求google，然后将数据返回给代理客户端，
代理客户端将数据返回给客户端.  

反向代理, 代理的是服务端，也就是假装是原始服务器。代理服务端代理的是真实的服务端，用户发起请求到代理服务端，代理服务端去请求真实服务端，真实服务端
将数据返回给代理服务端，代理服务端将数据返回给用户，看起来就像代理服务端直接给用户返回的数据一样，用户是无感知的，这样可以保护真实的服务端不被攻击。  

反向代理这名字贼烂，叫服务端代理多好，字面意思。控制反转(ioc-inversion-of-control)，听着很蒙B吧，martin flower大师给改个名叫依赖注入(DI,dependency_inject)，好理解多了。








