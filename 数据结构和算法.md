1. 递归: 指的是自己调用自己。每个递归函数都有两个条件：基线条件(让递归停止的条件),递归条件(让递归进行下去的条件)  
![avatar](./static/digui1.png)

![avatar](./static/digui2.png)

玩转数据结构递归笔记：  
本质上，是将原来的问题，转化为更小的同一问题  

```
public static int sum(int[] arr,int l){
if(l == arr.length)
    return 0;                        ------------------> 求解最基本问题
return arr[l] + sum(arr,l+1);  -------------------> 把原问题转化为更小的问题
}
```

### 排序
1. 冒泡排序:   
```
/**
 * 冒泡排序(从小到大，从大到小)
 */
public class BubbleSort {

    public static void main(String[] args) {
        // 从左到右，从小到大排序
        // [2,1,7,9,5,8]
        int [] arr = new int[]{2,1,7,9,5,8};
        sort(arr);
        sorted(arr);
        System.out.println(Arrays.toString(arr));
    }

    /**
     * 从左到右，从小到大排序
     */
    public static void sort(int[] arr) {

        boolean hasChange = true;

        // 外层循环控制每次循环次数
        for (int i = 0; i < arr.length - 1 && hasChange; i++) {
            hasChange = false;

            //内层循环两两比较，如果当前数比下一个数大，就swap
            for (int j = 0; j < arr.length - 1 - i; j++) {

                if (arr[j] > arr[j + 1]) {
                    swap(arr, j, j + 1);
                    hasChange = true;
                }
            }
        }
    }
    /**
     * 从左到右，从大到小排序
     */
    public static void sorted(int[] arr){

        boolean hasChange = true;

        // 外层循环控制内层循环次数
        for (int i=0;i<arr.length-1&hasChange;i++){

            hasChange = false;

            for (int j =0;j<arr.length-1-i;j++){
                if (arr[j]<arr[j+1]){
                    swap(arr,j,j+1);
                    hasChange = true;
                }
            }
        }
    }

    public static void swap(int[] arr, int index1, int index2) {
        // 存储被替代的临时变量
        int temp = arr[index1];
        arr[index1] = arr[index2];
        arr[index2] = temp;
    }
}
```

2. 
插入排序:首先，我们将数组中的数据分为两个区间，***已排序区间*** 
和***未排序区间***。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。  

插入排序也包含两种操作，一种是元素的比较，一种是元素的移动。当我们需要将一个数据 a 插入到已排序区间时，需要拿 a 
与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。  

学习算法和数据结构:理解和练,3分学,7分练


精通一个领域:  
chunk it up(切碎知识点)  理解理论，逐步去理解，切开后逐个击破
deliberate practicing(刻意练习)  敲代码运行练习 练习缺陷，弱点的地方，带来的心态是:不舒服，不爽，枯燥。这种情况是正常的  
feedback(反馈)  做笔记


|排序算法|时间复杂度|是否基于比较|
|:---:|:---:|:---:|
|冒泡，插入，选择|O(n2)|是|
|归并，快排|O(n*logN)|是|
|桶，计数，基数|O(n)|否|

