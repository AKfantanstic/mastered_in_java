## G1优化实战案例：百万用户级在线教育平台，如何基于G1垃圾回收器优化性能

* 背景:百万注册用户的在线教育平台，高峰期为3小时，总共60万活跃用户，平均每个用户上课1小时，每小时有20万活跃用户同时学习，20万用户每分钟进行1次互动操作，1小时会进行60次互动操作，20万用户在1小时内会进行1200万次互动，平均每秒钟进行3000次互动操作，根据经验，部署5台4核8G的机器，每台机器每秒钟抗600个请求。每台机器每秒有600个请求会占用3MB内存
  
* 优化前参数:堆内存分配4GB，其中新生代默认初始占比为5%，最大占比为60%，每个Java栈内存为1MB，元数据区为256MB。"-XX:G1NewSizePercent"参数用于设置新生代初始占比，这里维持默认值为5%，"-XX:G1MaxNewSizePercent"参数用来设置新生代最大占比，这里维持默认值60%。堆内存4G，除以2048，每个Region为2MB，新生代初始占比5%，新生代占用100个Region，有200MB内存空间。"-XX:MaxGcPauseMills"参数设置最大停顿时间，这里保持默认值为200ms。
  
* 优化分析:系统开始运行时，不停在Eden区分配对象，每秒分配3MB对象，1分钟左右会塞满100个Region，但是不会触发GC，因为回收这100个Region大概只需要几十ms，远低于预设的最大停顿时间200ms，因为如果此时Gc，那1分钟后会再次触发gc，会导致频繁GC，所以G1此时会给新生代增加分配Region，然后到一个时刻，通过计算发现回收目前新生代占用的这些Region大概需要200ms，此时才会触发一次新生代gc
  
* 新生代GC优化方式:对于G1，首先给整个JVM堆足够的内存，然后设置合理的"-XX:MaxGcPauseMills"参数。如果参数设置过小，说明每次gc停顿时间可能会特别短，此时G1发现几十个Region占满就会立即触发新生代GC，会导致gc触发会特别频繁。如果参数设置过大，G1会不断给新生代分配Region，然后再一次性回收几百个Region，此时GC停顿时间会很长，达到几百ms，但是GC频率很低。通过系统压测用户、gc日志分析、内存分析工具等结合，尽量让系统gc频率不能太高，每次GC停顿时间也不能太长，达到一个合理的理想值
  
* MixedGC优化方式:MixedGC的触发时机是当老年代占据堆内存的45%就会触发，新生代进入老年代的几个条件，对象年龄太大，动态年龄判断规则，新生代gc后存活对象太多无法放入Survivor。最关键的两个条件就是新生代gc后存活对象太多导致无法放入Survivor区和动态年龄判断规则，这两个条件可能会让很多本应该在新生代呆着的对象快速进入了老年代，导致老年代频繁达到堆内存45%的阈值然后频繁触发MixedGC。核心优化点还是"-XX:MaxGcPauseMills"值不能过大，因为如果设置的很大，会导致系统运行很久才会触发新生代GC，
  如果这时新生代占用达到堆内存60%才触发新生代GC，存活下来的对象就会有很多，就会导致survivor区放不下，就会被转移到老年代。
  又或者新生代GC后存活下来的对象过多，达到了survivor区50%，这样进入Survivor区后就触发了动态年龄判断规则，
  也会导致一些对象快速进入老年代。

>1. 一些负载很低的系统，JVM 本身就没什么好调优的
>2. G1非常适合超大内存的机器，因为如果内存太大用parNew+CMS，则会导致每次新生代GC都是内存快满了才开始回收，导致停顿时间太长，而用了G1可以指定每次GC的停顿时间，通过每次回收部分region的方式就可以达成这个目标
> 3. 一定要坚持，学习技术就是这样的，长期跟着坚持下来，收获就会很大
>4. G1主要针对内存大的场景，或者是业务不能有太高时延的情况,其他情况可以用ParNew+CMS
>5. JVM调优没那么复杂，关键是明白背后的原理，然后调节几个关键参数就可以了
>6. 使用JVm的系统最怕的就是Stop the world时间过长，系统卡不卡是受gc频率和"-XX:MaxGcPauseMills"每次gc停顿时间所决定的。主要的卡顿问题就是因为内存分配、参数设置不合理，导致对象频繁进入老年代，然后频繁触发老年代GC，导致系统频繁每隔几分钟就要卡住几秒钟
