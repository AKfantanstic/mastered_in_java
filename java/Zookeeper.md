### zookeeper的常见使用场景？
(1)分布式协调:经典用法。A系统发送请求到mq，然后B系统消费之后处理了，A系统如何知道B系统的处理结果呢?用zk来实现分布式系统之间的协调工作。A系统发送请求后可以在zk上对某个节点的值注册个监听器，一旦B系统处理完了就修改zk那个节点的值，A立马就可以收到通知。
(2)分布式锁：对某一个数据连续发出两个修改请求，两台机器同时收到了请求，但是只能一台机器先执行完后另一个机器再执行。那么此时就可以使用zk分布式锁，一个机器接受到了请求后先获取zk上的一把分布式锁，就是去创建一个znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。
(3)元数据/配置信息管理：zk可以用作很多系统的配置信息管理，比如kafka，storm等很多分布式系统都会使用zk来做一些元数据，配置信息的管理，包括dubbo注册中心也支持zk
(4)HA高可用性:这个应该是很常见的，比如hdfs，yarn等很多大数据系统，都选择基于zk来开发HA高可用机制，就是一个重要进程一般会做主备两个，主进程挂了立马通过zk

## 一般实现分布式锁有两种方式？使用redis如何设计分布式锁？使用zk如何来设计分布式锁？这两种分布式锁的实现方式哪种效率较高？

### Redis实现的分布式锁：
官方叫做 redLock 算法，是redis官方支持的分布式锁算法。
这个分布式锁有3个重要的考量点，互斥(只能有一个客户端获取锁)，不能死锁，容错(大部分redis节点获得这个锁就可以释放)
第一种最普通的实现方式，就是在redis里创建一个key算作加锁。
set my:lock 随机值 NX PX 30000，这个命令就ok，这里NX的意思就是只有key不存在的时候才会设置成功， PX 30000的意思就是30秒后锁自动释放。别恩创建时发现key已经存在就不能加锁了。

释放锁就是删除key，一般使用lua脚本删除，判断value一样才可以删除:
```
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else 
	return0
end
```
为什么要用随机值呢？因为如果某个客户端获取到了锁，但是阻塞了很长时间才执行完，此时可能已经自动释放锁了，此时可能别的客户端已经获取到了这个锁，要是这个时候直接删除key的话是会有问题的，所以得用随机值加上面的lua脚本来释放锁。

但是这样是肯定不行的，因为如果是普通的redis单实例，那就是单点故障，或者是redis普通主从，那redis是异步复制，如果主节点挂了，key还没同步到从节点，此时从结点切换为主节点，其他人就会拿到锁。

所以引出redlock算法。这个场景假设有一个redis cluster，有5个redis master实例，然后执行如下步骤获取一把锁:
(1)获取当前时间戳，单位是毫秒
(2)跟上面类似，轮流尝试在每个master节点上创建锁，过期时间较短，一般就几十毫秒
(3)尝试在大多数节点上建立一个锁，比如5个节点就要求是3个节点(n/2 + 1)
(4)客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了
(5)要是锁建立失败，那么就依次删除这个锁
(6)只要别人建立了一把分布式锁，你就得不断轮询去尝试获取锁

### zk分布式锁
zk分布式锁，其实可以做的比较简单，就是某个节点尝试创建临时znode，此时创建成功了就获取了这个锁，这个时候别的客户端来创建锁会失败，只能注册个监听器监听这个锁。释放锁就是删除这个znode，一旦释放锁就会通知客户端，然后有一个等待着的客户端就可以再次重新加锁

### redis分布式锁和zk分布式锁的对比
redis分布式锁，其实需要自己不断去尝试获取锁，比较消耗性能
zk分布式锁，获取不到锁，注册个监听器即可，不需要不断主动尝试获取锁，性能开销较小

另外一点就是，如果是redis获取锁的那个客户端bug了，或者挂了，那么只能等待超时时间之后才能释放锁；而zk，因为创建的是临时node，只要客户端挂了，znode就没了，此时就自动释放锁