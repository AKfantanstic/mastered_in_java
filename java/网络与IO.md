## 网络与IO连环炮
>1. Netty的架构原理图能画一下吗？他是如何提现Reactor架构思想的？
>2. 能说说你对Netty堆外内存的理解吗？什么情况下会使用堆外内存？
>3. 你遇到过堆外内存溢出或者堆外内存泄漏的场景吗？怎么解决的？
>4. 能聊聊你对零拷贝技术的理解吗？他到底是如何提升性能的？
>5. 你知道哪些开源的中间件系统用了零拷贝技术吗？为什么那些系统要使用零拷贝技术？
>6. 你了解过在操作系统层面，系统区内存和用户区内存的关系是什么吗？
>7. 说说你对序列化机制的理解，了解过protobuf吗？他是用来干什么的知道吗？ 

### 能说说你对堆外内存的理解吗？堆外内存的优势在哪里？
堆外内存就是不受jvm直接管理而直接向操作系统申请的内存。  
使用方式:
```
ByteBuffer buffer = ByteBuffer.allocateDirect(1024); // 传入的是要申请的堆外内存大小(按字节计)
// 申请好堆外内存后，可以直接将数据通过DirectByteBuffer写入这块内存，然后把数据直接通过socket发送，不需要走拷贝
```
优势：堆内数据要想通过网络IO发送出去，需要先拷贝到堆外内存，然后再写入socket里发送出去;而如果数据分配在堆外内存，不需要有额外一次拷贝，性能较高

### JVM是如何对堆外内存进行分配和回收的？堆外内存会发生内存溢出吗？原因？
通过DirectByteBuffer这个对象来分配堆外内存，这个对象是JVM堆内存里的一个对象，但是这个DirectByteBuffer里面包含指针，可以操作一块堆外内存。当要申请一块80MB的堆外内存时:
>1. 如果堆外内存足够，直接预留一块内存供DirectByteBuffer对象来操作
>2. 如果堆外内存不足以分配，则将已经被JVM垃圾回收的DirectByteBuffer对象的堆外内存释放
>3. 如果进行一次堆外内存回收后，还不够本次堆外内存分配就进行System.gc
>4. 如果9次尝试后依旧没有足够用的堆外内存，则抛异常
>5. 实际分配内存

当jvm gc回收DirectByteBuffer对象时会主动释放这些对象引用的堆外内存。也可以通过反射获取DirectByteBuffer内部的cleaner对象，
调用clean方法来主动释放内存。

* 当DirectByteBuffer躲过N次minor gc进入了老年代，然后老年代迟迟没有触发gc来回收内存时，可能回导致老年代的DirectByteBuffer
对象一直引用着堆外内存，如果这时需要分配更多的堆外内存时，就无法腾出更多的内存导致堆外内存溢出了。堆外内存溢出也会导致oom。
可通过 -XX:MaxDirectMemorySize参数设置最大可使用堆外内存

### 如果不使用零拷贝技术，普通IO操作在OS层面是如何执行的？
![avatar](../static/网络IO过程(普通IO).jpg)
```
File file = new File("xxx.txt");
RandomAccessFile raf = new RandomAccessFile(file,"rw");
byte[] arr = new Byte[(int)file.length()]
raf.read(arr);

Socket socket = new ServerSocket(8080).accept();
socket.getOutputStream.write(arr);
```
读取数据:使用read读取文件数据，需要先基于DMA引擎把磁盘上的文件数据拷贝到内核缓冲区(用户态切换到内核态)，然后再利用cpu把内存缓冲区里的数据拷贝到用户缓冲区里(内核态切换到用户态)  

写入数据:调用socket的输出流的write方法,利用cpu把用户缓冲区里的数据拷贝到socket缓冲区里(用户态切换到内核态)，紧接着会基于DMA引擎把socket缓冲区里的数据拷贝到网络协议引擎里，都完成后，从内核态切换回用户态

* 普通IO操作性能低下的原因:从本地磁盘读取数据，到通过网络发送出去，在用户态和内核态之间要发生4次切换，数据从磁盘拿出来后，要经过4次拷贝。4次拷贝和4次切换使普通IO操作性能较低

### 听过说mmap吗？内存映射技术为什么可以提高IO性能？
![avatar](../static/网络IO过程(基于mmap).jpg)
mmap，内存映射，就是把磁盘文件映射到内核缓冲区，这个映射过程是基于DMA引擎拷贝的，用户缓冲区和内核缓冲区共享1块映射数据，建立映射后，就不需要从内核缓冲区拷贝到用户缓冲区了，这里避免了一次拷贝，但是这个过程还是会从用户态切换到内核态进行映射拷贝，然后再从内核态切换到用户态，建立用户缓冲区和内核缓冲区的映射，然后把数据通过socket发送出去，然后切换到内核态，把内核缓冲区里的数据拷贝到socket缓冲区里，然后拷贝到网络协议引擎里发送出去，最后切换回用户态。减少一次拷贝，但并不减少切换次数，一共是4次切换，3次拷贝。

mmap避免了从内核缓冲区到用户缓冲区的一次拷贝,RocketMQ底层基于mmap技术提升了磁盘文件的读写性能  
### 零拷贝技术到底是什么？它是如何提升IO性能的？
Linux提供了sendfile，也就是零拷贝技术。
* 在java中基于零拷贝技术来读取磁盘文件并通过Socket发送出去的代码，参考kafka源码中transferFrom和transferTo两个方法。
* 零拷贝过程: 
>1. 先从用户态切换到内核态，在内核态下把磁盘数据拷贝到内核缓冲区，同时从内核缓冲区拷贝offset和length到Socket缓冲区；
>2. 然后从内核态切换到用户态，从内核缓冲区通过DMA拷贝直接将数据拷贝到网卡里，同时从Socket缓冲区里拷贝一些offset和length到网卡里，但是这个offset和length的量很少，几乎可以忽略。这个过程只需要2次切换，2次拷贝即可完成

* kafka、tomcat使用了零拷贝技术，rocketmq使用了mmap，mmap要比零拷贝多2次切换和1次拷贝的。