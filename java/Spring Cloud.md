## 电商系统使用Spring Cloud架构图:
![avatar](../static/电商系统使用SpringCloud架构.png)

## SpringCloud四大核心组件:
* Eureka:服务注册中心
* Feign:服务调用
* Ribbon:负载均衡
* Zuul/Spring Cloud Gateway:网关

Hystrix、链路追踪、Stream等很多组件，并不是说一个普通系统刚开始就必须得用的，如果用了没有用好反而会出问题。Hystrix线路熔断的框架必须得设计对应的一整套限流方案、熔断方案、资源隔离方案、降级方案等机制，来配合降级机制来做。

## 

## SpringCloud接口请求处理流程:
基于SpringCloud对外发布一个接口，实际上就是对外发布一个最普通的SpringMVC的http接口。请求首先到达网关，
网关里配置了不同请求路径和服务的对应关系，由网关查找请求所要访问的服务，然后将请求转发给服务的某台机器，
然后这台机器要调用其他服务时，先访问的是打了feign注解的接口，然后feign对这个接口生成动态代理，
当针对feign的动态代理去调用方法时，会在底层生成http协议格式的请求，/order/create?productId=1,
然后先通过Ribbon从本地的Eureka注册表缓存中获取出目标服务的机器列表，然后按照负载均衡算法选出一台机器，
然后使用Httpclient对这台机器发起Http请求。




## SpringCloud和Dubbo的优劣比较？
对于Dubbo，经过深度优化的RPC服务框架性能和并发是比HTTP更好的，Dubbo请求一次10ms，SpringCloud耗费20ms，但是对于中型公司而言，性能、并发并不是主要因素。
SpringCloud这套框架走Http请求就足够满足性能和并发的需要了，没必要使用高度优化的RPC服务框架。

## 服务注册中心的技术选型？
* Dubbo作为服务框架的，一般注册中心都会选择zk
* SpringCloud作为服务框架的，一般注册中心会选择Eureka
* consul、Nacos，普及还没那么广泛。
* 服务注册发现的原理:
>1. Eureka:peer-to-peer，集群部署，集群里每个机器的地位是对等的，每个微服务可以向任何一个Eureka实例进行注册和服务发现，集群里任何一个Eureka实例接收到写请求后会自动同步给其他所有的Eureka实例
>2. zookeeper:服务注册和发现，分为leader + follower 两种角色，服务注册只能发给leader，只有leader可以负责接收写请求(也就是服务注册)
，然后由leader将数据同步给follower，读的时候leader/follower都可以读
* 一致性保障:CP or AP
CAP,C是一致性、A是可用性、P是分区容错性
>1. zookeeper选择实现CP，zookeeper只由一个leader节点来接收数据，然后同步给其他follower节点，当一旦leader挂了要重新选举leader，这个过程为了保证C，就牺牲了A，会导致zookeeper
在leader选举期间不可用一段时间。当leader选举完成后，就可以继续写数据了，保证了强一致性
>2. Eureka是peer模式，在微服务注册后还没有同步给其他实例时本实例宕机，会丢失注册消息，此时微服务还可以继续从别的机器上拉取注册表，但是不是最新的数据。这样保证了可用性、最终一致性
* 服务注册发现的时效性:
zookeeper的时效性更好，当服务注册或者是服务宕机，一般能做到秒级感知。
Eureka默认配置非常糟糕，服务发现要几十秒，甚至分钟级别。上线一个新的服务实例到其他服务可以发现他，极端情况下要1分钟时间，由ribbon去获取每个服务上缓存的eureka注册表进行负载均衡。当服务故障时，Eureka每隔60秒才去检查心跳，如果发现这个服务上一次心跳是在60秒之前，然后再隔60秒去检查心跳，超过90秒没有心跳，才会认为服务宕机，两分钟过去了，然后eureka 30秒才会更新缓存，然后再过30秒其他服务才会来拉取最新的注册表。如果一个服务实例宕机，到其他服务发现宕机，可能要2、3分钟时间
* 容量:
>1. zookeeper不适合大规模的服务实例，因为服务上下线时需要瞬间推送数据到所有其他服务实例，一旦服务实例规模太大到几千个服务实例时，会导致网络带宽被大量占用
>2. eureka也很难支撑大规模的服务实例，因为每个eureka实例都要接收所有请求，实例多了压力太大扛不住，所以很难到几千个服务实例




























































