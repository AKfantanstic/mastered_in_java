* 设计模式是专门用于封装面向过程的方法，把面向过程的方法按面向对象的方法去优化。面向对象思想就是封装，面向对象的代码能随时准备被复用.
* 设计模式就是归纳出在面向对象开发中的不同场景下，犯的很多面向过程的错，用面向对象的思想去改造优化的方法，达到低耦合，增强面向对象代码的可维护性和可扩展性
* 设计模式的要义就是: 提升面向对象代码的可维护性和可扩展性
* 设计模式是一门按面向对象场景去彻底消除重复代码的功课，如何通过良好的面向对象类的设计去消除不同场景中存在的重复代码
* 设计模式最核心的要义就是消除重复代码，绝对不写任何重复代码
* 如果第一次写代码，不用急于去生搬硬套设计模式，但是等第二次即将编写重复代码时，就要利用设计模式去避免编写重复代码了
* 设计模式也可以用来对各个模式适用的场景去重构代码，用设计模式对重复代码进行重构
* 武侠小说中比较low的那种练武之人，就是只会照搬招式，一板一眼跟着练。而真正的顶尖高手，都是理解了武侠秘籍的思想，然后无招胜有招。设计模式的重点是思想，理解了思想，随便你招式怎么出，只要能运用设计模式的思想去运用到实际业务场景中，避免写出屎一样的代码，你就成功了。反之如果照搬设计模式去写，反而增加了代码的复杂度

### 策略模式:

夹杂在多重if-else之间的业务逻辑代码，属于面向过程编程。而策略模式用面向对象思想去封装代码。

面向场景:多重if-else判断

```java
    /**
     * 没用策略模式优化的 面向过程的代码:
     * 缺点:
     * 1. 一年后回头看代码会发现看不懂了
     * 2. 因为封装不好，如果代码有改动，可能需要改多个地方的相同代码逻辑，增加出错几率
     */
    public void withoutStrategyPattentMethod() {
        int discountType = 1;
        if (discountType == 1) {
            System.out.println("执行打折方式 1 的复杂业务逻辑");
        } else if (discountType == 2) {
            System.out.println("执行打折方式 2 的复杂业务逻辑");
        } else if (discountType == 3) {
            System.out.println("执行打折方式 3 的复杂业务逻辑");
        } else {
            System.out.println("执行默认打折方式的复杂业务逻辑");
        }
    }
```

```java
import lombok.Getter;
import lombok.Setter;

/**
 * 落地策略模式:
 * 要点1：必须将if else的代码，封装到不同的策略类中
 * 要点2：将选择哪种策略的逻辑给放到一个工厂类中去，选择策略的代码一定要简洁
 * 要点3：context可有可无，具体是看你的策略执行这块如果就一行代码调用，不需要context。
 * 如果context中的策略执行逻辑较为复杂一点，context来封装策略类的执行逻辑
 */
public class StrategyPatternDemo {

    /**
     * 第一步:
     * 声明接口，用来封装不同if else中的执行逻辑
     */
    public interface DiscountCalculateStrategy {
        void calculate();
    }

    /**
     * 第二步:
     * 新建执行类 实现 策略接口
     */
    public static class DiscountCalculateStrategyA implements DiscountCalculateStrategy {
        @Override
        public void calculate() {
            System.out.println("执行优惠计价方式1的复杂业务逻辑");
        }
    }

    public static class DiscountCalculateStrategyB implements DiscountCalculateStrategy {
        @Override
        public void calculate() {
            System.out.println("执行优惠计价方式2的复杂业务逻辑");
        }
    }

    public static class DiscountCalculateStrategyC implements DiscountCalculateStrategy {
        @Override
        public void calculate() {
            System.out.println("执行优惠计价方式3的复杂业务逻辑");
        }
    }

    public static class DiscountCalculateStrategyDefault implements DiscountCalculateStrategy {
        @Override
        public void calculate() {
            System.out.println("执行默认的优惠计价方式的复杂业务逻辑");
        }
    }

    /**
     * 第三步:
     * 把选择哪种策略的逻辑 封装到 策略模式工厂类中
     */
    public static class DiscountCalculateStrategyFactory {

        /**
         * 工厂根据打折类型来创建不同策略
         *
         * @param discountStyle
         * @return
         */
        public static DiscountCalculateStrategy getDiscountCalculateStrategy(int discountStyle) {
            if (discountStyle == 1) {
                return new DiscountCalculateStrategyA();
            } else if (discountStyle == 2) {
                return new DiscountCalculateStrategyB();
            } else if (discountStyle == 3) {
                return new DiscountCalculateStrategyC();
            } else {
                return new DiscountCalculateStrategyDefault();
            }
        }
    }

    /**
     * 第四步:
     * (可选)如果策略的执行逻辑较为复杂，用context来封装策略类的执行逻辑
     */
    @Getter
    @Setter
    public static class Context {

        private DiscountCalculateStrategy strategy;

        /**
         * 在这里封装策略的执行逻辑
         */
        public void calculate() {
            strategy.calculate();
        }
    }

    public static void main(String[] args) {
        // 打折类型
        int discountStyle = 1;
        
        DiscountCalculateStrategy strategy = DiscountCalculateStrategyFactory
                .getDiscountCalculateStrategy(discountStyle);

        Context context = new Context();
        context.setStrategy(strategy);
        context.calculate();
    }
}
```

### 原型模式:

面向场景:拷贝对象

在类中封装对象拷贝逻辑，来避免让类的使用者去手动拷贝属性

```java
import lombok.Data;

/**
 * 这段代码的问题是什么？
 * 假设不同的地方要拷贝对象，只能每次手动编写对象拷贝过程，会造成相同的拷贝逻辑分散在不同地方，如果修改拷贝逻辑，多个调用地方都要修改代码，可维护性和可扩展性很差
 * 问题就是代码中还是面向过程的思想，而面向对象思想，就要针对这个对象的拷贝过程进行封装，来提升面向对象代码的可维护性和可扩展性
 */
public class WithoutPrototypePatternDemo {

    public static void main(String[] args) {
        // 待拷贝对象
        Product product = new Product("测试产品", new Component("测试组件"));
        // 拷贝对象，只能利用构造方法来new对象的方式 手动拷贝对象
        Product copyProduct = new Product(product.getName(), product.getComponent());
        System.out.println("执行使用拷贝对象的业务逻辑 :" + copyProduct);
    }

    @Data
    public static class Component {

        private String name;

        public Component(String name) {
            super();
            this.name = name;
        }
    }

    @Data
    public static class Product {

        private String name;
        private Component component;

        public Product(String name, Component component) {
            super();
            this.name = name;
            this.component = component;
        }
    }
}
```

```java
import lombok.Data;

/**
 * 原型模式:
 * 在要拷贝的类里实现一个clone()方法，给调用者提供一个自我拷贝的方法。这样即使clone()方法逻辑修改了，调用者也无需修改代码
 * <p>
 * 拷贝分为深拷贝和浅拷贝
 */
public class PrototypePatternDemo {

    public static void main(String[] args) {
        Product product = new Product("测试产品", new Component("测试组件"));
        Product copyProduct = (Product) product.clone();
        System.out.println("执行使用拷贝对象的业务逻辑 :" + copyProduct);
    }

    @Data
    public static class Component {

        private String name;

        public Component(String name) {
            super();
            this.name = name;
        }

        @Override
        protected Object clone() {
            return new Component(getName());
        }
    }

    @Data
    public static class Product {

        private String name;
        private Component component;

        public Product(String name, Component component) {
            super();
            this.name = name;
            this.component = component;
        }

        @Override
        protected Object clone() {
            // 浅拷贝
//			return new Product(getName(), getComponent());

            // 深拷贝，递归对自己引用的对象也进行拷贝
            return new Product(getName(), (Component) getComponent().clone());
        }
    }
}
```

### 代理模式:

面向场景:增强方法

代理类和源类同时实现一个接口，代理类中方法对源类方法进行增强

```java
// 如果不使用代理模式，只能通过拷贝代码
```

```java
/**
 * 代理模式:
 */
public class ProxyPatternDemo {
    public static void main(String[] args) {
        // 创建源对象
        Subject subject = new OriginSubject();
        // 用源对象创建代理类
        Subject proxy = new Proxy(subject);
        // 调用代理类中被增强过的方法
        proxy.request();
    }

    /**
     * 定义接口
     */
    public interface Subject {
        void request();
    }

    /**
     * 实现接口的源类
     */
    public static class OriginSubject implements Subject {
        @Override
        public void request() {
            System.out.println("执行请求");
        }
    }

    /**
     * 实现接口的代理类
     */
    public static class Proxy implements Subject {

        private Subject subject;

        public Proxy(Subject subject) {
            this.subject = subject;
        }

        @Override
        public void request() {
            // 对源类方法的增强逻辑
            System.out.println("用条件判断是否要调用subject的request()方法");
            boolean invoke = true;
            if (invoke) {
                subject.request();
            }
        }
    }
}
```

### 责任链模式:

面向场景:存在多个业务流程，并且这些业务流程之间有相同的功能逻辑，只是步骤不同

```java
/**
 * 不使用责任链模式:
 * <p>
 * 场景:有两个业务流程，都是由功能逻辑123排列组合而成。
 * 存在的问题:
 * 1. 存在大量重复代码，假如对功能逻辑进行修改，需要修改多个地方。
 * 2. 如果对某个业务流程顺序进行调整，要修改大量代码，封装性不好。
 */
public class WithoutChainPatternDemo {

    public static void main(String[] args) {
        // 业务流程1
        System.out.println("执行功能逻辑1");
        System.out.println("执行功能逻辑2");
        System.out.println("执行功能逻辑3");

        // 业务流程2
        System.out.println("执行功能逻辑3");
        System.out.println("执行功能逻辑1");
        System.out.println("执行功能逻辑2");
    }
}
```

```java
/**
 * 责任链模式:
 * 1. 把一个业务流程中的多个步骤拆分开，每个步骤封装到一个 handler 处理器中去，使 handler 成为可以复用的代码组件
 * 2. 然后把业务流程基于 handler组件 来动态组装
 * <p>
 * 好处:
 * 1. 如果某个步骤代码逻辑需要修改，只修改一个 handler 即可
 * 2. 如果业务流程有变更，无需拷贝大量代码，直接基于 handler 组件进行动态组装
 */
public class ChainPatternDemo {

    /**
     * 第一步: 定义抽象类
     * 类的一个属性定义为该抽象类，
     * 然后定义一个抽象执行方法让子类去实现
     */
    public static abstract class Handler {

        protected Handler successor;

        public Handler(Handler successor) {
            this.successor = successor;
        }

        public abstract void execute();
    }

    /**
     * 第二步:子类继承抽象类，覆写父类构造方法，
     * 然后实现父类的抽象执行方法
     */
    public static class Handler1 extends Handler {

        public Handler1(Handler successor) {
            super(successor);
        }

        @Override
        public void execute() {
            System.out.println("执行功能1");
            if (successor != null) {
                successor.execute();
            }
        }
    }

    public static class Handler2 extends Handler {

        public Handler2(Handler successor) {
            super(successor);
        }

        @Override
        public void execute() {
            System.out.println("执行功能2");
            if (successor != null) {
                successor.execute();
            }
        }
    }

    public static class Handler3 extends Handler {

        public Handler3(Handler successor) {
            super(successor);
        }

        @Override
        public void execute() {
            System.out.println("执行功能3");
            if (successor != null) {
                successor.execute();
            }
        }
    }

    public static void main(String[] args) {
        /**
         * 第三步，组装责任链
         */
        // 用责任链模式改造 业务流程1----> 功能1 -> 功能2 -> 功能3
        Handler thirdHandler = new Handler3(null);
        Handler secondHandler = new Handler2(thirdHandler);
        Handler firstHandler = new Handler1(secondHandler);
        firstHandler.execute();

        // 用责任链模式改造 业务流程2----> 功能3 -> 功能1 -> 功能2
        thirdHandler = new Handler2(null);
        secondHandler = new Handler1(thirdHandler);
        firstHandler = new Handler3(secondHandler);
        firstHandler.execute();
    }
}
```

### 命令模式:

面向场景:需要执行不同命令

```java
import lombok.Setter;

/**
 * 命令模式:
 * 比如缓存架构，有两种请求要发送过来执行，一种请求是读请求，一种请求是写请求，不同请求要执行的功能逻辑是不一样的。
 * 此时就非常适合用命令模式。
 * 将读请求的功能逻辑封装到ReadCommand里面去，将写请求的功能逻辑封装到WriteCommand里面去，然后设置一个通用的一个命令执行的类，
 * 当读请求来了，就封装ReadCommand，交给同一个命令执行类来执行即可；
 * 当写请求来了，就封装WriteCommand，交给同一个命令感知性类来执行即可
 */
public class CommandPatternDemo {

    /**
     * 第一步:定义命令接口
     */
    public interface Command {
        void execute();
    }

    /**
     * 读请求类 实现命令接口
     */
    public static class ReadCommand implements Command {
        @Override
        public void execute() {
            System.out.println("读请求的功能逻辑");
        }
    }

    /**
     * 写请求类 实现命令接口
     */
    public static class WriteCommand implements Command {
        @Override
        public void execute() {
            System.out.println("写请求的功能逻辑");
        }
    }

    /**
     * 调用者类，专用来执行命令
     */
    @Setter
    public static class Invoker {

        private Command command;

        public void execute() {
            System.out.println("一些别的逻辑A");
            command.execute();
            System.out.println("一些别的逻辑B");
        }
    }

    public static void main(String[] args) {
        // 创建具体命令对象
        Command readCommand = new ReadCommand();
        Command writeCommand = new WriteCommand();

        // 创建调用者类
        Invoker invoker = new Invoker();

        // 让调用者来执行 读请求 命令
        invoker.setCommand(readCommand);
        invoker.execute();
        // 让调用者来执行 写请求 命令
        invoker.setCommand(writeCommand);
        invoker.execute();
    }
}
```

### 模板方法模式:

面向场景:不同方法中存在相同的一段通用逻辑

```java
/**
 * 不用模板模式的实现
 * 存在的问题:三种打折计算器类中都存在一段完全相同的通用计算逻辑代码，通过复制粘贴的方式放到了不同类中
 * <p>
 * 以后要修改那段通用计算逻辑代码时，需要在3个地方修改3次。一旦忘记修改一处后果不堪设想，
 * 而且到了后期几乎没人记得清楚那段通用计算逻辑到底放在了多少个类中，排查过程相当复杂
 * <p>
 * 这段垃圾代码对修改不友好，可维护性和可扩展性很差
 */
public class WithoutTemplateMethodPatternDemo {

    /**
     * 打折计算器类A
     */
    public static class DiscountCalculatorA {
        public void calculate() {
            System.out.println("通用的计算逻辑，修改了一下");
            System.out.println("优惠计算器1的特殊计算逻辑");
        }
    }

    /**
     * 打折计算器类B
     */
    public static class DiscountCalculatorB {
        public void calculate() {
            System.out.println("通用的计算逻辑，修改了一下");
            System.out.println("优惠计算器2的特殊计算逻辑");
        }
    }

    /**
     * 打折计算器类C
     */
    public static class DiscountCalculatorC {
        public void calculate() {
            // 漏掉修改类C的通用计算逻辑，出现问题
            System.out.println("通用的计算逻辑");
            System.out.println("优惠计算器3的特殊计算逻辑");
        }
    }

    public static void main(String[] args) {
        DiscountCalculatorA calculatorA = new DiscountCalculatorA();
        // 计算打折方式A
        calculatorA.calculate();

        DiscountCalculatorB calculatorB = new DiscountCalculatorB();
        // 计算打折方式B
        calculatorB.calculate();

        DiscountCalculatorC calculatorC = new DiscountCalculatorC();
        // 计算打折方式C
        calculatorC.calculate();
    }
}
```

```java
/**
 * 模板方法模式:
 * 当通用逻辑修改时，只需要改一处即可
 */
public class TemplateMethodPatterDemo {

    /**
     * 第一步:定义一个 打折计算 接口
     */
    public interface DiscountCalculator {
        void calculate();
    }

    /**
     * 第二步:定义一个 抽象类 实现 打折计算接口，
     * <p>
     * 抽象类中覆写打折计算接口的方法来组合通用逻辑和特殊逻辑，在抽象类的非抽象方法中封装通用逻辑，
     * 把特殊方法定义为抽象方法，让子类自己去实现
     * <p>
     * 模板方法实现的精华所在
     */
    public static abstract class AbstractDiscountCalculator implements DiscountCalculator {
        @Override
        public void calculate() {
            // 完成通用的计算逻辑
            commonCalculate();
            // 完成特殊的计算逻辑
            specificCalculate();
        }

        // 把 通用方法 封装在抽象类内部
        private void commonCalculate() {
            System.out.println("通用的计算逻辑，修改了一下");
        }

        // 把 特殊方法 暴露给子类来实现
        protected abstract void specificCalculate();
    }

    /**
     * 打折计算类1 继承抽象类，只需要覆写父类的抽象方法即可
     */
    public static class DiscountCalculator1 extends AbstractDiscountCalculator {
        @Override
        public void specificCalculate() {
            System.out.println("优惠计算器1的特殊计算逻辑");
        }
    }

    /**
     * 打折计算类2 继承抽象类，只需要覆写父类的抽象方法即可
     */
    public static class DiscountCalculator2 extends AbstractDiscountCalculator {
        @Override
        public void specificCalculate() {
            System.out.println("优惠计算器2的特殊计算逻辑");
        }
    }

    /**
     * 打折计算类3 继承抽象类，只需要覆写父类的抽象方法即可
     */
    public static class DiscountCalculator3 extends AbstractDiscountCalculator {
        @Override
        public void specificCalculate() {
            System.out.println("优惠计算器3的特殊计算逻辑");
        }
    }

    public static void main(String[] args) {
        DiscountCalculator calculator1 = new DiscountCalculator1();
        calculator1.calculate();

        DiscountCalculator calculator2 = new DiscountCalculator2();
        calculator2.calculate();

        DiscountCalculator calculator3 = new DiscountCalculator3();
        calculator3.calculate();
    }
}
```

### 装饰者模式:

```java
/**
 * 装饰者模式:
 * 对实现了相同接口的类，装饰者类负责对其进行增强
 */
public class DecoratorPatternDemo {

    /**
     * 第一步: 定义一个接口
     */
    public interface Component {
        void execute();
    }

    /**
     * 第二步: 定义一个普通组件类实现接口
     */
    public static class CommonComponent implements Component {

        @Override
        public void execute() {
            System.out.println("执行基础功能");
        }
    }

    /**
     * 第三步: 定义装饰者类也实现接口，并把接口作为装饰者类的一个属性
     * 然后在覆写接口方法中，对接口子类方法进行增强
     */
    public static class Decorator implements Component {

        private Component component;

        public Decorator(Component component) {
            this.component = component;
        }

        @Override
        public void execute() {
            System.out.println("在执行基础功能之前，执行部分功能增强");
            component.execute();
            System.out.println("在执行基础功能之后，执行部分功能增强");
        }
    }

    public static void main(String[] args) {
        // 新建一个普通组件对象
        Component component = new CommonComponent();
        // 构建一个普通组件对象的装饰对象
        Component decorator = new Decorator(component);
        // 调用被装饰者装饰后的方法
        decorator.execute();
    }
}
```

### 迭代器模式:

面向场景:迭代访问

```java
import lombok.Data;
import lombok.Getter;
import lombok.Setter;

import java.util.HashMap;
import java.util.Map;

/**
 * 不用迭代器模式的实现:
 * 直接去遍历一个类中的集合，一旦这个类中对集合的使用改版了，比如从数组 -> map，迭代方法的代码就需要改动，
 * 如果业务逻辑很复杂，同时集合类的实现和遍历代码的实现，是两个人开发的，一边协调一边改动，成本就很高了，
 * 可扩展性和可维护性很差
 */
public class WithoutIteratorPatternDemo {

    /**
     * 学生类
     */
    @Data
    public static class Student {

        private String name;

        public Student(String name) {
            this.name = name;
        }
    }

    /**
     * 教室类(用来容纳很多学生)
     */
    @Getter
    @Setter
    public static class Classroom {
        // 更改类中集合的使用 -> private Student[] students;
        private Map<String, Student> students;
    }

    public static void main(String[] args) {
        Student student1 = new Student("小明");
        Student student2 = new Student("小王");

//      原来是用数组容器存储元素，使用数组的访问方式
//		Student[] students = new Student[2];
//		students[0] = student1;
//		students[1] = student2;
//      Student[] resultStudents = classroom.getStudents();
//		for(Student resultStudent: resultStudents) {
//			System.out.println(resultStudent);
//		}

        // 现在改为用集合容器存储元素，使用集合的访问方式
        Map<String, Student> students = new HashMap<String, Student>();
        students.put(student1.getName(), student1);
        students.put(student2.getName(), student2);

        Classroom classroom = new Classroom();
        classroom.setStudents(students);
        // map容器的访问方式
        Map<String, Student> resultStudents = classroom.getStudents();
        for (Student resultStudent : resultStudents.values()) {
            System.out.println(resultStudent);
        }
    }
}
```

```java
import lombok.Data;

import java.util.ArrayList;
import java.util.List;

/**
 * 用迭代器模式的实现:
 * 使用了迭代器模式后，迭代逻辑的修改无需去修改业务代码
 */
public class IteratorPatternDemo {

    /**
     * 第一步:自定义一个元素类，这里是学生类
     */
    @Data
    public static class Student {
        private String name;

        public Student(String name) {
            this.name = name;
        }
    }

    /**
     * 第二步:自定义一个保存元素的集合容器，这里是教室类
     */
    public static class Classroom {
        //	    private Student[] students;
        private List<Student> students;

        /**
         * last相当于是数组的长度
         */
        private int last = 0;

        public Classroom(int size) {
//	        this.students = new Student[size];
            this.students = new ArrayList<>(size);
        }

        public Student getStudent(int index) {
//	        return students[index];
            return students.get(index);
        }

        public void addStudent(Student student) {
//	        this.students[last] = student;
            this.students.add(student);
            last++;
        }

        public int getLength() {
            return last;
        }

        /**
         * 返回一个教室迭代器，其中封装了教室自己，让迭代器可以获取教室中的数据
         */
        public ClassroomIterator iterator() {
            return new ClassroomIterator(this);
        }
    }

    /**
     * 自定义一个迭代器接口
     *
     * @param <E>
     */
    public interface CustomIterator<E> {
        boolean hasNext();

        E next();
    }

    /**
     * 第三步:定义一个集合迭代器类来实现自定义迭代器接口，专门用来迭代第二步所定义的集合
     */
    public static class ClassroomIterator implements CustomIterator {

        private Classroom classroom;
        private int index;

        public ClassroomIterator(Classroom classroom) {
            this.classroom = classroom;
            this.index = 0;
        }

        /**
         * 假设此时index是0，classroom的length是2
         * 那么肯定是可以去获取下一个学生的，此时数组还没遍历完
         * <p>
         * 假设此时index是2，classroom的length是2，classroom可以遍历的数组的offset只能是0和1
         */
        @Override
        public boolean hasNext() {
            if (index < classroom.getLength()) {
                return true;
            } else {
                return false;
            }
        }

        /**
         * 从数组中获取当前的这个学生，同时将index往下移动一位
         * 比如一开始index是0，然后数组长度是2
         * 此时遍历获取了第一个学生之后，返回了数组的0元素，然后将index变为1了
         */
        @Override
        public Object next() {
            Student student = classroom.getStudent(index);
            index++;
            return student;
        }
    }

    public static void main(String[] args) {
        Student student1 = new Student("小明");
        Student student2 = new Student("小王");

        Classroom classroom = new Classroom(2);
        classroom.addStudent(student1);
        classroom.addStudent(student2);

        // 使用了迭代器模式后，迭代逻辑的修改无需去修改业务代码
        CustomIterator<Student> iterator = classroom.iterator();
        while (iterator.hasNext()) {
            Student student = iterator.next();
            System.out.println(student);
        }
    }
}
```

### 观察者模式:

```java
import lombok.Getter;

import java.util.Observable;
import java.util.Observer;

/**
 * 观察者模式:
 * 被观察者状态变化时，通知观察者
 */
public class ObserverPatternDemo {

    /**
     * 第一步:定义一个 被观察类
     */
    @Getter
    public static class Subject extends Observable {
        // 定义被观察的属性
        private Integer state;

        public Subject(Integer state) {
            this.state = state;
        }

        public void setState(Integer state) {
            // 修改状态
            this.state = state;
            // 先通知关联的观察者们状态发生变化了
            this.setChanged();
            // 再通知观察者(带参数)
            this.notifyObservers(state);
            // 再通知观察者(无参)
            this.notifyObservers();
        }
    }

    /**
     * 第二步:定义一个观察者
     */
    public static class CommonObserver implements Observer {

        @Override
        public void update(Observable o, Object arg) {
//			Integer state = (Integer) arg;
            Subject subject = (Subject) o;
            Integer state = subject.getState();
            System.out.println("我是观察者，观察到目标对象的状态变化成：" + state);
        }
    }

    public static void main(String[] args) {
        // 新建一个被观察对象
        Subject subject = new Subject(0);
        // 新建一个观察者
        Observer observer = new CommonObserver();
        // 把 观察者 添加到 被观察对象的观察列表
        subject.addObserver(observer);
        // 修改被观察者的状态，验证观察效果
        subject.setState(1);
        subject.setState(2);
    }
}
```

### 状态模式:

```java

```



### 组合模式:

把操作层级数据的方法封装在类内部，避免由调用方编写操作方法

面向场景:需要使用一个类或几个类维护树形结构

```java
import lombok.Getter;
import lombok.Setter;

import java.util.ArrayList;
import java.util.List;

/**
 * 维护树形结构，不使用组合模式的问题:
 * 要操作层级数据，需要由调用方编写大量的 if-for 等屎一样的代码，一年后没人能看懂这些代码
 */
public class WithoutCompositePatternDemo {

    @Getter
    @Setter
    public static class Department {

        private String name;
        private List<Department> children = new ArrayList<>();

        public Department(String name) {
            this.name = name;
        }

        public void remove() {
            System.out.println("删除部门【" + name + "】");
        }
    }

    public static void main(String[] args) {
        /**
         * 构建一棵树形部门结构，然后删除
         *
         *             父部门
         *             /    \
         *          子部门1  子部门2
         *          /    \        \
         *    叶子部门1   叶子部门2  叶子部门3
         */
        Department leafDept1 = new Department("叶子部门1");
        Department leafDept2 = new Department("叶子部门2");
        Department leafDept3 = new Department("叶子部门3");

        Department subDept1 = new Department("子部门1");
        subDept1.getChildren().add(leafDept1);
        subDept1.getChildren().add(leafDept2);

        Department subDept2 = new Department("子部门2");
        subDept2.getChildren().add(leafDept3);

        Department parentDept = new Department("父部门");
        parentDept.getChildren().add(subDept1);
        parentDept.getChildren().add(subDept2);

        for (Department subDept : parentDept.getChildren()) {
            if (subDept.getChildren().size() > 0) {
                for (Department leafDept : subDept.getChildren()) {
                    leafDept.remove();
                }
            }
            subDept.remove();
        }
        parentDept.remove();
    }
}
```

```java
/**
 * 组合模式:
 * 第一要义，将树形结构的数据用一个类或者少数一两个类，就可以拼装成一棵树的形状
 * 第二要义，当调用者对一个父级数据执行某个操作时，这个操作要直接递归调用所有父级下的孩子数据的相关操作
 * <p>
 * 把父级数据的操作方法封装在类内部，避免让调用方编写屎一样的 if-for 代码，达到自己递归自己
 */
public class CompositePatternDemo {

    @Getter
    @Setter
    public static class Department {
        private String name;
        private List<Department> children = new ArrayList<>();

        public Department(String name) {
            this.name = name;
        }

        /**
         * 只有一步:把维护树形结构的部分封装在类的内部，避免由调用方来编写
         */
        public void remove() {
            if (children.size() > 0) {
                for (Department child : children) {
                    child.remove();
                }
            }
            System.out.println("删除部门【" + name + "】");
        }
    }

    public static void main(String[] args) {
        /**
         * 构建一棵树形部门结构，然后删除
         *
         *             父部门
         *             /    \
         *          子部门1  子部门2
         *          /    \        \
         *    叶子部门1   叶子部门2  叶子部门3
         */
        Department leafDept1 = new Department("叶子部门1");
        Department leafDept2 = new Department("叶子部门2");
        Department leafDept3 = new Department("叶子部门3");

        Department subDept1 = new Department("子部门1");
        subDept1.getChildren().add(leafDept1);
        subDept1.getChildren().add(leafDept2);

        Department subDept2 = new Department("子部门2");
        subDept2.getChildren().add(leafDept3);

        Department parentDept = new Department("父部门");
        parentDept.getChildren().add(subDept1);
        parentDept.getChildren().add(subDept2);

        parentDept.remove();
    }
}
```









































### 1. 动态代理:

用场景举例:有个叫IHelloWorld接口及其实现类HelloWorld，它有一个叫sayHello()的方法。现在需要在sayHello()之前和之后，额外加一些日志的输出。  
两种方式实现：(1)手动写一个类HelloWorldEx
```
public class HelloWorldEx implements IHelloWorld {
    IHelloWorld hw;

    public HelloWorldEx(IHelloWorld hw) {
        this.hw = hw;
    }

    public void sayHello() {
        Logger.startLog();
        hw.sayHello();
        Logger.endLog();
    }
}
```
(2) 有个接口(IHelloWorld)及其实现类(HelloWorld)， 然后有个InvocationHandler的实现，最后用Proxy.newProxyInstance(....)创建一个新的类出来。  

那么手动写一个类HelloWorldEx和用Proxy.newProxyInstance来创建，有什么区别呢？  
实现的功能是相同的，但是HelloWorldEx需要事先写好，编译后不能改了，相当于写死了！如果我想对Order类，Employee类，Department类，也想加点儿日志，还得写个OrderEx，EmployeeEx，DepartmentEx的类，太麻烦了！
而Proxy.newProxyInstance这种方法，可以在程序运行的时候为任意类动态地创建增强的类。
事先写死的叫做静态代理，Proxy.newProxyInstance这种方式叫做动态代理，更加灵活。  

那么为什么要创建新的代理类，那个Proxy.newProxyInstance不能直接修改老的HelloWorld类吗？  
Java本质是一个静态类型的语言，class一旦被装入JVM，是不能修改`添加`删除方法的，那么既然老的class不能修改，就只能通过代理的方式来创建新的类了。  
动态代理主要应用场景:记日志，安全方面。具体功能主要由aop来实现。AOP中经常会以声明的方式提出这样的要求：某个包下所有add开头的方法，在执行之前都要调用Logger.startLog()方法，
在执行之后都要调用Logger.endLog()方法。或者对于所有以Service结尾的类，所有的方法执行之前都要调用tx.begin()，执行之后都要调用tx.commit(), 如果抛出异常的话调用tx.rollback()。  

AOP中经常有这样的需求......  ，Spring想添加这些日志和事务的功能，但是却没有办法去修改用户的类，它是框架啊，一是不知道用户类的源码，二是Java不允许再修改装载入JVM的class。
没办法，Spring只好在运行时找到用户的类，然后操作字节码动态创建一个新类，新类会对原有的类进行增强，添加日志，事务这些功能，注意啊，这些都是在内存中动态创建的。
这就是JDK的动态代理，不过它有个前提要求，就是用户的类需要实现接口才行。  

CgLib提供了另外一种对现有类增强的办法，动态生成的类继承了现有的类，两者是“父子关系”。  

