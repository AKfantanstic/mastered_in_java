1. 动态代理:
用场景举例:有个叫IHelloWorld接口及其实现类HelloWorld，它有一个叫sayHello()的方法。现在需要在sayHello()之前和之后，额外加一些日志的输出。  
两种方式实现：(1)手动写一个类HelloWorldEx
```
public class HelloWorldEx implements IHelloWorld {
    IHelloWorld hw;

    public HelloWorldEx(IHelloWorld hw) {
        this.hw = hw;
    }

    public void sayHello() {
        Logger.startLog();
        hw.sayHello();
        Logger.endLog();
    }
}
```
(2) 有个接口(IHelloWorld)及其实现类(HelloWorld)， 然后有个InvocationHandler的实现，最后用Proxy.newProxyInstance(....)创建一个新的类出来。  

那么手动写一个类HelloWorldEx和用Proxy.newProxyInstance来创建，有什么区别呢？  
实现的功能是相同的，但是HelloWorldEx需要事先写好，编译后不能改了，相当于写死了！如果我想对Order类，Employee类，Department类，也想加点儿日志，还得写个OrderEx，EmployeeEx，DepartmentEx的类，太麻烦了！
而Proxy.newProxyInstance这种方法，可以在程序运行的时候为任意类动态地创建增强的类。
事先写死的叫做静态代理，Proxy.newProxyInstance这种方式叫做动态代理，更加灵活。  

那么为什么要创建新的代理类，那个Proxy.newProxyInstance不能直接修改老的HelloWorld类吗？  
Java本质是一个静态类型的语言，class一旦被装入JVM，是不能修改`添加`删除方法的，那么既然老的class不能修改，就只能通过代理的方式来创建新的类了。  
动态代理主要应用场景:记日志，安全方面。具体功能主要由aop来实现。AOP中经常会以声明的方式提出这样的要求：某个包下所有add开头的方法，在执行之前都要调用Logger.startLog()方法，
在执行之后都要调用Logger.endLog()方法。或者对于所有以Service结尾的类，所有的方法执行之前都要调用tx.begin()，执行之后都要调用tx.commit(), 如果抛出异常的话调用tx.rollback()。  

AOP中经常有这样的需求......  ，Spring想添加这些日志和事务的功能，但是却没有办法去修改用户的类，它是框架啊，一是不知道用户类的源码，二是Java不允许再修改装载入JVM的class。
没办法，Spring只好在运行时找到用户的类，然后操作字节码动态创建一个新类，新类会对原有的类进行增强，添加日志，事务这些功能，注意啊，这些都是在内存中动态创建的。
这就是JDK的动态代理，不过它有个前提要求，就是用户的类需要实现接口才行。  

CgLib提供了另外一种对现有类增强的办法，动态生成的类继承了现有的类，两者是“父子关系”。  