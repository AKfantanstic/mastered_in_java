* 设计模式是专门用于封装面向过程的方法，把面向过程的方法按面向对象的方法去优化。面向对象思想就是封装，面向对象的代码能随时准备被复用.
* 设计模式就是归纳出在面向对象开发中的不同场景下，犯的很多面向过程的错，用面向对象的思想去改造优化的方法，达到低耦合，增强面向对象代码的可维护性和可扩展性
* 设计模式的要义就是: 提升面向对象代码的可维护性和可扩展性
* 设计模式是一门按面向对象场景去彻底消除重复代码的功课，如何通过良好的面向对象类的设计去消除不同场景中存在的重复代码
* 设计模式，是一门面向对象设计的艺术
* 设计模式最核心的要义就是消除重复代码，绝对不写任何重复代码
* 如果第一次写代码，不用急于去生搬硬套设计模式，但是等第二次即将编写重复代码时，就要利用设计模式去避免编写重复代码了
* 设计模式也可以用来对各个模式适用的场景去重构代码，用设计模式对重复代码进行重构
* 武侠小说中比较low的那种练武之人，就是只会照搬招式，一板一眼跟着练。而真正的顶尖高手，都是理解了武侠秘籍的思想，然后无招胜有招。设计模式的重点是思想，理解了思想，随便你招式怎么出，只要能运用设计模式的思想去运用到实际业务场景中，避免写出屎一样的代码，你就成功了。反之如果照搬设计模式去写，反而增加了代码的复杂度

### 策略模式:

夹杂在多重if-else之间的业务逻辑代码，属于面向过程编程。而策略模式用面向对象思想去封装代码。

适用场景:多重if-else判断

```java
    /**
     * 没用策略模式优化的 面向过程的代码:
     * 缺点:
     * 1. 一年后回头看代码会发现看不懂了
     * 2. 因为封装不好，如果代码有改动，可能需要改多个地方的相同代码逻辑，增加出错几率
     */
    public void withoutStrategyPattentMethod() {
        int discountType = 1;
        if (discountType == 1) {
            System.out.println("执行打折方式 1 的复杂业务逻辑");
        } else if (discountType == 2) {
            System.out.println("执行打折方式 2 的复杂业务逻辑");
        } else if (discountType == 3) {
            System.out.println("执行打折方式 3 的复杂业务逻辑");
        } else {
            System.out.println("执行默认打折方式的复杂业务逻辑");
        }
    }
```

```java
import lombok.Getter;
import lombok.Setter;

/**
 * 落地策略模式:
 * 要点1：必须将if else的代码，封装到不同的策略类中
 * 要点2：将选择哪种策略的逻辑给放到一个工厂类中去，选择策略的代码一定要简洁
 * 要点3：context可有可无，具体是看你的策略执行这块如果就一行代码调用，不需要context。
 * 如果context中的策略执行逻辑较为复杂一点，context来封装策略类的执行逻辑
 */
public class StrategyPatternDemo {

    /**
     * 第一步:
     * 声明接口，用来封装不同if else中的执行逻辑
     */
    public interface DiscountCalculateStrategy {
        void calculate();
    }

    /**
     * 第二步:
     * 新建执行类 实现 策略接口
     */
    public static class DiscountCalculateStrategyA implements DiscountCalculateStrategy {
        @Override
        public void calculate() {
            System.out.println("执行优惠计价方式1的复杂业务逻辑");
        }
    }

    public static class DiscountCalculateStrategyB implements DiscountCalculateStrategy {
        @Override
        public void calculate() {
            System.out.println("执行优惠计价方式2的复杂业务逻辑");
        }
    }

    public static class DiscountCalculateStrategyC implements DiscountCalculateStrategy {
        @Override
        public void calculate() {
            System.out.println("执行优惠计价方式3的复杂业务逻辑");
        }
    }

    public static class DiscountCalculateStrategyDefault implements DiscountCalculateStrategy {
        @Override
        public void calculate() {
            System.out.println("执行默认的优惠计价方式的复杂业务逻辑");
        }
    }

    /**
     * 第三步:
     * 把选择哪种策略的逻辑 封装到 策略模式工厂类中
     */
    public static class DiscountCalculateStrategyFactory {

        /**
         * 工厂根据打折类型来创建不同策略
         *
         * @param discountStyle
         * @return
         */
        public static DiscountCalculateStrategy getDiscountCalculateStrategy(int discountStyle) {
            if (discountStyle == 1) {
                return new DiscountCalculateStrategyA();
            } else if (discountStyle == 2) {
                return new DiscountCalculateStrategyB();
            } else if (discountStyle == 3) {
                return new DiscountCalculateStrategyC();
            } else {
                return new DiscountCalculateStrategyDefault();
            }
        }
    }

    /**
     * 第四步:
     * (可选)如果策略的执行逻辑较为复杂，用context来封装策略类的执行逻辑
     */
    @Getter
    @Setter
    public static class Context {

        private DiscountCalculateStrategy strategy;

        /**
         * 在这里封装策略的执行逻辑
         */
        public void calculate() {
            strategy.calculate();
        }
    }

    public static void main(String[] args) {
        // 打折类型
        int discountStyle = 1;
        
        DiscountCalculateStrategy strategy = DiscountCalculateStrategyFactory
                .getDiscountCalculateStrategy(discountStyle);

        Context context = new Context();
        context.setStrategy(strategy);
        context.calculate();
    }
}
```

### 原型模式:

适用场景:拷贝对象

在类中封装对象拷贝逻辑，来避免让类的使用者去手动拷贝属性

```java
import lombok.Data;

/**
 * 这段代码的问题是什么？
 * 假设不同的地方要拷贝对象，只能每次手动编写对象拷贝过程，会造成相同的拷贝逻辑分散在不同地方，如果修改拷贝逻辑，多个调用地方都要修改代码，可维护性和可扩展性很差
 * 问题就是代码中还是面向过程的思想，而面向对象思想，就要针对这个对象的拷贝过程进行封装，来提升面向对象代码的可维护性和可扩展性
 */
public class WithoutPrototypePatternDemo {

    public static void main(String[] args) {
        // 待拷贝对象
        Product product = new Product("测试产品", new Component("测试组件"));
        // 拷贝对象，只能利用构造方法来new对象的方式 手动拷贝对象
        Product copyProduct = new Product(product.getName(), product.getComponent());
        System.out.println("执行使用拷贝对象的业务逻辑 :" + copyProduct);
    }

    @Data
    public static class Component {

        private String name;

        public Component(String name) {
            super();
            this.name = name;
        }
    }

    @Data
    public static class Product {

        private String name;
        private Component component;

        public Product(String name, Component component) {
            super();
            this.name = name;
            this.component = component;
        }
    }
}
```

```java
import lombok.Data;

/**
 * 原型模式:
 * 在要拷贝的类里实现一个clone()方法，给调用者提供一个自我拷贝的方法。这样即使clone()方法逻辑修改了，调用者也无需修改代码
 * <p>
 * 拷贝分为深拷贝和浅拷贝
 */
public class PrototypePatternDemo {

    public static void main(String[] args) {
        Product product = new Product("测试产品", new Component("测试组件"));
        Product copyProduct = (Product) product.clone();
        System.out.println("执行使用拷贝对象的业务逻辑 :" + copyProduct);
    }

    @Data
    public static class Component {

        private String name;

        public Component(String name) {
            super();
            this.name = name;
        }

        @Override
        protected Object clone() {
            return new Component(getName());
        }
    }

    @Data
    public static class Product {

        private String name;
        private Component component;

        public Product(String name, Component component) {
            super();
            this.name = name;
            this.component = component;
        }

        @Override
        protected Object clone() {
            // 浅拷贝
//			return new Product(getName(), getComponent());

            // 深拷贝，递归对自己引用的对象也进行拷贝
            return new Product(getName(), (Component) getComponent().clone());
        }
    }
}
```

### 代理模式:

适用场景:增强方法

代理类和源类同时实现一个接口，代理类中方法对源类方法进行增强

```java
// 如果不使用代理模式，只能通过拷贝代码
```

```java
/**
 * 代理模式:
 */
public class ProxyPatternDemo {
    public static void main(String[] args) {
        // 创建源对象
        Subject subject = new OriginSubject();
        // 用源对象创建代理类
        Subject proxy = new Proxy(subject);
        // 调用代理类中被增强过的方法
        proxy.request();
    }

    /**
     * 定义接口
     */
    public interface Subject {
        void request();
    }

    /**
     * 实现接口的源类
     */
    public static class OriginSubject implements Subject {
        @Override
        public void request() {
            System.out.println("执行请求");
        }
    }

    /**
     * 实现接口的代理类
     */
    public static class Proxy implements Subject {

        private Subject subject;

        public Proxy(Subject subject) {
            this.subject = subject;
        }

        @Override
        public void request() {
            // 对源类方法的增强逻辑
            System.out.println("用条件判断是否要调用subject的request()方法");
            boolean invoke = true;
            if (invoke) {
                subject.request();
            }
        }
    }
}
```

### 责任链模式:

适用场景:存在多个业务流程，并且这些业务流程之间有相同的功能逻辑，只是步骤不同

```java
/**
 * 不使用责任链模式:
 * <p>
 * 场景:有两个业务流程，都是由功能逻辑123排列组合而成。
 * 存在的问题:
 * 1. 存在大量重复代码，假如对功能逻辑进行修改，需要修改多个地方。
 * 2. 如果对某个业务流程顺序进行调整，要修改大量代码，封装性不好。
 */
public class WithoutChainPatternDemo {

    public static void main(String[] args) {
        // 业务流程1
        System.out.println("执行功能逻辑1");
        System.out.println("执行功能逻辑2");
        System.out.println("执行功能逻辑3");

        // 业务流程2
        System.out.println("执行功能逻辑3");
        System.out.println("执行功能逻辑1");
        System.out.println("执行功能逻辑2");
    }
}
```

```java
/**
 * 责任链模式:
 * 1. 把一个业务流程中的多个步骤拆分开，每个步骤封装到一个 handler 处理器中去，使 handler 成为可以复用的代码组件
 * 2. 然后把业务流程基于 handler组件 来动态组装
 * <p>
 * 好处:
 * 1. 如果某个步骤代码逻辑需要修改，只修改一个 handler 即可
 * 2. 如果业务流程有变更，无需拷贝大量代码，直接基于 handler 组件进行动态组装
 */
public class ChainPatternDemo {

    /**
     * 第一步: 定义抽象类
     * 类的一个属性定义为该抽象类，
     * 然后定义一个抽象执行方法让子类去实现
     */
    public static abstract class Handler {

        protected Handler successor;

        public Handler(Handler successor) {
            this.successor = successor;
        }

        public abstract void execute();
    }

    /**
     * 第二步:子类继承抽象类，覆写父类构造方法，
     * 然后实现父类的抽象执行方法
     */
    public static class Handler1 extends Handler {

        public Handler1(Handler successor) {
            super(successor);
        }

        @Override
        public void execute() {
            System.out.println("执行功能1");
            if (successor != null) {
                successor.execute();
            }
        }
    }

    public static class Handler2 extends Handler {

        public Handler2(Handler successor) {
            super(successor);
        }

        @Override
        public void execute() {
            System.out.println("执行功能2");
            if (successor != null) {
                successor.execute();
            }
        }
    }

    public static class Handler3 extends Handler {

        public Handler3(Handler successor) {
            super(successor);
        }

        @Override
        public void execute() {
            System.out.println("执行功能3");
            if (successor != null) {
                successor.execute();
            }
        }
    }

    public static void main(String[] args) {
        /**
         * 第三步，组装责任链
         */
        // 用责任链模式改造 业务流程1----> 功能1 -> 功能2 -> 功能3
        Handler thirdHandler = new Handler3(null);
        Handler secondHandler = new Handler2(thirdHandler);
        Handler firstHandler = new Handler1(secondHandler);
        firstHandler.execute();

        // 用责任链模式改造 业务流程2----> 功能3 -> 功能1 -> 功能2
        thirdHandler = new Handler2(null);
        secondHandler = new Handler1(thirdHandler);
        firstHandler = new Handler3(secondHandler);
        firstHandler.execute();
    }
}
```

### 命令模式:

适用场景:需要执行不同命令

```java
import lombok.Setter;

/**
 * 命令模式:
 * 比如缓存架构，有两种请求要发送过来执行，一种请求是读请求，一种请求是写请求，不同请求要执行的功能逻辑是不一样的。
 * 此时就非常适合用命令模式。
 * 将读请求的功能逻辑封装到ReadCommand里面去，将写请求的功能逻辑封装到WriteCommand里面去，然后设置一个通用的一个命令执行的类，
 * 当读请求来了，就封装ReadCommand，交给同一个命令执行类来执行即可；
 * 当写请求来了，就封装WriteCommand，交给同一个命令感知性类来执行即可
 */
public class CommandPatternDemo {

    /**
     * 第一步:定义命令接口
     */
    public interface Command {
        void execute();
    }

    /**
     * 读请求类 实现命令接口
     */
    public static class ReadCommand implements Command {
        @Override
        public void execute() {
            System.out.println("读请求的功能逻辑");
        }
    }

    /**
     * 写请求类 实现命令接口
     */
    public static class WriteCommand implements Command {
        @Override
        public void execute() {
            System.out.println("写请求的功能逻辑");
        }
    }

    /**
     * 调用者类，专用来执行命令
     */
    @Setter
    public static class Invoker {

        private Command command;

        public void execute() {
            System.out.println("一些别的逻辑A");
            command.execute();
            System.out.println("一些别的逻辑B");
        }
    }

    public static void main(String[] args) {
        // 创建具体命令对象
        Command readCommand = new ReadCommand();
        Command writeCommand = new WriteCommand();

        // 创建调用者类
        Invoker invoker = new Invoker();

        // 让调用者来执行 读请求 命令
        invoker.setCommand(readCommand);
        invoker.execute();
        // 让调用者来执行 写请求 命令
        invoker.setCommand(writeCommand);
        invoker.execute();
    }
}
```

### 模板方法模式:

适用场景:不同方法中存在相同的一段通用逻辑

```java
/**
 * 不用模板模式的实现
 * 存在的问题:三种打折计算器类中都存在一段完全相同的通用计算逻辑代码，通过复制粘贴的方式放到了不同类中
 * <p>
 * 以后要修改那段通用计算逻辑代码时，需要在3个地方修改3次。一旦忘记修改一处后果不堪设想，
 * 而且到了后期几乎没人记得清楚那段通用计算逻辑到底放在了多少个类中，排查过程相当复杂
 * <p>
 * 这段垃圾代码对修改不友好，可维护性和可扩展性很差
 */
public class WithoutTemplateMethodPatternDemo {

    /**
     * 打折计算器类A
     */
    public static class DiscountCalculatorA {
        public void calculate() {
            System.out.println("通用的计算逻辑，修改了一下");
            System.out.println("优惠计算器1的特殊计算逻辑");
        }
    }

    /**
     * 打折计算器类B
     */
    public static class DiscountCalculatorB {
        public void calculate() {
            System.out.println("通用的计算逻辑，修改了一下");
            System.out.println("优惠计算器2的特殊计算逻辑");
        }
    }

    /**
     * 打折计算器类C
     */
    public static class DiscountCalculatorC {
        public void calculate() {
            // 漏掉修改类C的通用计算逻辑，出现问题
            System.out.println("通用的计算逻辑");
            System.out.println("优惠计算器3的特殊计算逻辑");
        }
    }

    public static void main(String[] args) {
        DiscountCalculatorA calculatorA = new DiscountCalculatorA();
        // 计算打折方式A
        calculatorA.calculate();

        DiscountCalculatorB calculatorB = new DiscountCalculatorB();
        // 计算打折方式B
        calculatorB.calculate();

        DiscountCalculatorC calculatorC = new DiscountCalculatorC();
        // 计算打折方式C
        calculatorC.calculate();
    }
}
```

```java
/**
 * 模板方法模式:
 * 当通用逻辑修改时，只需要改一处即可
 */
public class TemplateMethodPatterDemo {

    /**
     * 第一步:定义一个 打折计算 接口
     */
    public interface DiscountCalculator {
        void calculate();
    }

    /**
     * 第二步:定义一个 抽象类 实现 打折计算接口，
     * <p>
     * 抽象类中覆写打折计算接口的方法来组合通用逻辑和特殊逻辑，在抽象类的非抽象方法中封装通用逻辑，
     * 把特殊方法定义为抽象方法，让子类自己去实现
     * <p>
     * 模板方法实现的精华所在
     */
    public static abstract class AbstractDiscountCalculator implements DiscountCalculator {
        @Override
        public void calculate() {
            // 完成通用的计算逻辑
            commonCalculate();
            // 完成特殊的计算逻辑
            specificCalculate();
        }

        // 把 通用方法 封装在抽象类内部
        private void commonCalculate() {
            System.out.println("通用的计算逻辑，修改了一下");
        }

        // 把 特殊方法 暴露给子类来实现
        protected abstract void specificCalculate();
    }

    /**
     * 打折计算类1 继承抽象类，只需要覆写父类的抽象方法即可
     */
    public static class DiscountCalculator1 extends AbstractDiscountCalculator {
        @Override
        public void specificCalculate() {
            System.out.println("优惠计算器1的特殊计算逻辑");
        }
    }

    /**
     * 打折计算类2 继承抽象类，只需要覆写父类的抽象方法即可
     */
    public static class DiscountCalculator2 extends AbstractDiscountCalculator {
        @Override
        public void specificCalculate() {
            System.out.println("优惠计算器2的特殊计算逻辑");
        }
    }

    /**
     * 打折计算类3 继承抽象类，只需要覆写父类的抽象方法即可
     */
    public static class DiscountCalculator3 extends AbstractDiscountCalculator {
        @Override
        public void specificCalculate() {
            System.out.println("优惠计算器3的特殊计算逻辑");
        }
    }

    public static void main(String[] args) {
        DiscountCalculator calculator1 = new DiscountCalculator1();
        calculator1.calculate();

        DiscountCalculator calculator2 = new DiscountCalculator2();
        calculator2.calculate();

        DiscountCalculator calculator3 = new DiscountCalculator3();
        calculator3.calculate();
    }
}
```

### 装饰者模式:

```java
/**
 * 装饰者模式:
 * 对实现了相同接口的类，装饰者类负责对其进行增强
 */
public class DecoratorPatternDemo {

    /**
     * 第一步: 定义一个接口
     */
    public interface Component {
        void execute();
    }

    /**
     * 第二步: 定义一个普通组件类实现接口
     */
    public static class CommonComponent implements Component {

        @Override
        public void execute() {
            System.out.println("执行基础功能");
        }
    }

    /**
     * 第三步: 定义装饰者类也实现接口，并把接口作为装饰者类的一个属性
     * 然后在覆写接口方法中，对接口子类方法进行增强
     */
    public static class Decorator implements Component {

        private Component component;

        public Decorator(Component component) {
            this.component = component;
        }

        @Override
        public void execute() {
            System.out.println("在执行基础功能之前，执行部分功能增强");
            component.execute();
            System.out.println("在执行基础功能之后，执行部分功能增强");
        }
    }

    public static void main(String[] args) {
        // 新建一个普通组件对象
        Component component = new CommonComponent();
        // 构建一个普通组件对象的装饰对象
        Component decorator = new Decorator(component);
        // 调用被装饰者装饰后的方法
        decorator.execute();
    }
}
```

### 迭代器模式:

适用场景:迭代访问

```java
import lombok.Data;
import lombok.Getter;
import lombok.Setter;

import java.util.HashMap;
import java.util.Map;

/**
 * 不用迭代器模式的实现:
 * 直接去遍历一个类中的集合，一旦这个类中对集合的使用改版了，比如从数组 -> map，迭代方法的代码就需要改动，
 * 如果业务逻辑很复杂，同时集合类的实现和遍历代码的实现，是两个人开发的，一边协调一边改动，成本就很高了，
 * 可扩展性和可维护性很差
 */
public class WithoutIteratorPatternDemo {

    /**
     * 学生类
     */
    @Data
    public static class Student {

        private String name;

        public Student(String name) {
            this.name = name;
        }
    }

    /**
     * 教室类(用来容纳很多学生)
     */
    @Getter
    @Setter
    public static class Classroom {
        // 更改类中集合的使用 -> private Student[] students;
        private Map<String, Student> students;
    }

    public static void main(String[] args) {
        Student student1 = new Student("小明");
        Student student2 = new Student("小王");

//      原来是用数组容器存储元素，使用数组的访问方式
//		Student[] students = new Student[2];
//		students[0] = student1;
//		students[1] = student2;
//      Student[] resultStudents = classroom.getStudents();
//		for(Student resultStudent: resultStudents) {
//			System.out.println(resultStudent);
//		}

        // 现在改为用集合容器存储元素，使用集合的访问方式
        Map<String, Student> students = new HashMap<String, Student>();
        students.put(student1.getName(), student1);
        students.put(student2.getName(), student2);

        Classroom classroom = new Classroom();
        classroom.setStudents(students);
        // map容器的访问方式
        Map<String, Student> resultStudents = classroom.getStudents();
        for (Student resultStudent : resultStudents.values()) {
            System.out.println(resultStudent);
        }
    }
}
```

```java
import lombok.Data;

import java.util.ArrayList;
import java.util.List;

/**
 * 用迭代器模式的实现:
 * 使用了迭代器模式后，迭代逻辑的修改无需去修改业务代码
 */
public class IteratorPatternDemo {

    /**
     * 第一步:自定义一个元素类，这里是学生类
     */
    @Data
    public static class Student {
        private String name;

        public Student(String name) {
            this.name = name;
        }
    }

    /**
     * 第二步:自定义一个保存元素的集合容器，这里是教室类
     */
    public static class Classroom {
        //	    private Student[] students;
        private List<Student> students;

        /**
         * last相当于是数组的长度
         */
        private int last = 0;

        public Classroom(int size) {
//	        this.students = new Student[size];
            this.students = new ArrayList<>(size);
        }

        public Student getStudent(int index) {
//	        return students[index];
            return students.get(index);
        }

        public void addStudent(Student student) {
//	        this.students[last] = student;
            this.students.add(student);
            last++;
        }

        public int getLength() {
            return last;
        }

        /**
         * 返回一个教室迭代器，其中封装了教室自己，让迭代器可以获取教室中的数据
         */
        public ClassroomIterator iterator() {
            return new ClassroomIterator(this);
        }
    }

    /**
     * 自定义一个迭代器接口
     *
     * @param <E>
     */
    public interface CustomIterator<E> {
        boolean hasNext();

        E next();
    }

    /**
     * 第三步:定义一个集合迭代器类来实现自定义迭代器接口，专门用来迭代第二步所定义的集合
     */
    public static class ClassroomIterator implements CustomIterator {

        private Classroom classroom;
        private int index;

        public ClassroomIterator(Classroom classroom) {
            this.classroom = classroom;
            this.index = 0;
        }

        /**
         * 假设此时index是0，classroom的length是2
         * 那么肯定是可以去获取下一个学生的，此时数组还没遍历完
         * <p>
         * 假设此时index是2，classroom的length是2，classroom可以遍历的数组的offset只能是0和1
         */
        @Override
        public boolean hasNext() {
            if (index < classroom.getLength()) {
                return true;
            } else {
                return false;
            }
        }

        /**
         * 从数组中获取当前的这个学生，同时将index往下移动一位
         * 比如一开始index是0，然后数组长度是2
         * 此时遍历获取了第一个学生之后，返回了数组的0元素，然后将index变为1了
         */
        @Override
        public Object next() {
            Student student = classroom.getStudent(index);
            index++;
            return student;
        }
    }

    public static void main(String[] args) {
        Student student1 = new Student("小明");
        Student student2 = new Student("小王");

        Classroom classroom = new Classroom(2);
        classroom.addStudent(student1);
        classroom.addStudent(student2);

        // 使用了迭代器模式后，迭代逻辑的修改无需去修改业务代码
        CustomIterator<Student> iterator = classroom.iterator();
        while (iterator.hasNext()) {
            Student student = iterator.next();
            System.out.println(student);
        }
    }
}
```

### 观察者模式:

```java
import lombok.Getter;

import java.util.Observable;
import java.util.Observer;

/**
 * 观察者模式:
 * 被观察者状态变化时，通知观察者
 */
public class ObserverPatternDemo {

    /**
     * 第一步:定义一个 被观察类
     */
    @Getter
    public static class Subject extends Observable {
        // 定义被观察的属性
        private Integer state;

        public Subject(Integer state) {
            this.state = state;
        }

        public void setState(Integer state) {
            // 修改状态
            this.state = state;
            // 先通知关联的观察者们状态发生变化了
            this.setChanged();
            // 再通知观察者(带参数)
            this.notifyObservers(state);
            // 再通知观察者(无参)
            this.notifyObservers();
        }
    }

    /**
     * 第二步:定义一个观察者
     */
    public static class CommonObserver implements Observer {

        @Override
        public void update(Observable o, Object arg) {
//			Integer state = (Integer) arg;
            Subject subject = (Subject) o;
            Integer state = subject.getState();
            System.out.println("我是观察者，观察到目标对象的状态变化成：" + state);
        }
    }

    public static void main(String[] args) {
        // 新建一个被观察对象
        Subject subject = new Subject(0);
        // 新建一个观察者
        Observer observer = new CommonObserver();
        // 把 观察者 添加到 被观察对象的观察列表
        subject.addObserver(observer);
        // 修改被观察者的状态，验证观察效果
        subject.setState(1);
        subject.setState(2);
    }
}
```

### 状态模式:

```java
/**
 * 状态模式:将不同的状态要执行的代码逻辑封装在不同的state类中，然后定义一个context类作为状态管理器，
 * 负责根据传入的参数来决定这份数据的状态流转到什么状态，以及负责执行那个新状态的代码逻辑。
 * 对于有状态的场景，按照面向对象的思想来设计。而不是说，在一堆代码里面，if 开始执行那个状态的一堆逻辑，
 * else if 开始执行另外一个状态的一堆逻辑，屎一样的代码
 * 代码清晰，可读性好，可维护性好
 * <p>
 * 适用场景:数据有状态，并且状态要发生流转
 */
public class StatePatternDemo {

    /**
     * 第一步:定义状态接口
     */
    public interface State {
        void execute();
    }

    /**
     * 第二步:定义具体类实现状态接口
     */
    public static class NewState implements State {
        @Override
        public void execute() {
            System.out.println("执行销售出库单新建状态的逻辑");
        }
    }

    public static class ApprovingState implements State {
        @Override
        public void execute() {
            System.out.println("执行销售出库单待审批状态的逻辑");
        }
    }

    public static class ApprovedState implements State {
        @Override
        public void execute() {
            System.out.println("执行销售出库单已审批状态的逻辑");
        }
    }

    public static class FinishedState implements State {
        @Override
        public void execute() {
            System.out.println("执行销售出库单已完成状态的逻辑");
        }
    }

    /**
     * 第三步:定义一个context容器用来接收状态，并控制状态流转
     */
    public static class Context {

        private State state;

        public Context(State state) {
            this.state = state;
            this.state.execute();
        }

        public void execute(int stateType) {
            if (stateType == 1) {
                this.state = new ApprovingState();
                this.state.execute();
            } else if (stateType == 2) {
                this.state = new ApprovedState();
                this.state.execute();
            } else if (stateType == 3) {
                this.state = new FinishedState();
                this.state.execute();
            }
        }
    }

    public static void main(String[] args) {
        Context context = new Context(new NewState());
        context.execute(1);
        context.execute(2);
        context.execute(3);
    }
}
```

### 组合模式:

把操作层级数据的方法封装在类内部，避免由调用方编写操作方法

适用场景:需要使用一个类或几个类维护树形结构

```java
import lombok.Getter;
import lombok.Setter;

import java.util.ArrayList;
import java.util.List;

/**
 * 维护树形结构，不使用组合模式的问题:
 * 要操作层级数据，需要由调用方编写大量的 if-for 等屎一样的代码，一年后没人能看懂这些代码
 */
public class WithoutCompositePatternDemo {

    @Getter
    @Setter
    public static class Department {

        private String name;
        private List<Department> children = new ArrayList<>();

        public Department(String name) {
            this.name = name;
        }

        public void remove() {
            System.out.println("删除部门【" + name + "】");
        }
    }

    public static void main(String[] args) {
        /**
         * 构建一棵树形部门结构，然后删除
         *
         *             父部门
         *             /    \
         *          子部门1  子部门2
         *          /    \        \
         *    叶子部门1   叶子部门2  叶子部门3
         */
        Department leafDept1 = new Department("叶子部门1");
        Department leafDept2 = new Department("叶子部门2");
        Department leafDept3 = new Department("叶子部门3");

        Department subDept1 = new Department("子部门1");
        subDept1.getChildren().add(leafDept1);
        subDept1.getChildren().add(leafDept2);

        Department subDept2 = new Department("子部门2");
        subDept2.getChildren().add(leafDept3);

        Department parentDept = new Department("父部门");
        parentDept.getChildren().add(subDept1);
        parentDept.getChildren().add(subDept2);

        for (Department subDept : parentDept.getChildren()) {
            if (subDept.getChildren().size() > 0) {
                for (Department leafDept : subDept.getChildren()) {
                    leafDept.remove();
                }
            }
            subDept.remove();
        }
        parentDept.remove();
    }
}
```

```java
/**
 * 组合模式:
 * 第一要义，将树形结构的数据用一个类或者少数一两个类，就可以拼装成一棵树的形状
 * 第二要义，当调用者对一个父级数据执行某个操作时，这个操作要直接递归调用所有父级下的孩子数据的相关操作
 * <p>
 * 把父级数据的操作方法封装在类内部，避免让调用方编写屎一样的 if-for 代码，达到自己递归自己
 */
public class CompositePatternDemo {

    @Getter
    @Setter
    public static class Department {
        private String name;
        private List<Department> children = new ArrayList<>();

        public Department(String name) {
            this.name = name;
        }

        /**
         * 只有一步:把维护树形结构的部分封装在类的内部，避免由调用方来编写
         */
        public void remove() {
            if (children.size() > 0) {
                for (Department child : children) {
                    child.remove();
                }
            }
            System.out.println("删除部门【" + name + "】");
        }
    }

    public static void main(String[] args) {
        /**
         * 构建一棵树形部门结构，然后删除
         *
         *             父部门
         *             /    \
         *          子部门1  子部门2
         *          /    \        \
         *    叶子部门1   叶子部门2  叶子部门3
         */
        Department leafDept1 = new Department("叶子部门1");
        Department leafDept2 = new Department("叶子部门2");
        Department leafDept3 = new Department("叶子部门3");

        Department subDept1 = new Department("子部门1");
        subDept1.getChildren().add(leafDept1);
        subDept1.getChildren().add(leafDept2);

        Department subDept2 = new Department("子部门2");
        subDept2.getChildren().add(leafDept3);

        Department parentDept = new Department("父部门");
        parentDept.getChildren().add(subDept1);
        parentDept.getChildren().add(subDept2);

        parentDept.remove();
    }
}
```

### 访问者模式:

```java
import lombok.Data;

import java.util.ArrayList;
import java.util.List;

/**
 * 访问者模式:
 * 一般是跟组合模式结合起来用。组合模式实际上代表了一种复杂的对象类型，
 * 如果后续要给树形的数据结构增加功能，直接去修改代码可能比较麻烦，
 * 而如果采用访问者模式来做，就可以在任何时候给树形结构增加任何功能
 */
public class VisitorPatternDemo {

    /**
     * 第一步:定义一个复杂类
     */
    @Data
    public static class Department {
        private String name;
        private List<Department> children = new ArrayList<>();

        public Department(String name) {
            super();
            this.name = name;
        }

        /**
         * 并定义一个方法来接收一个访问者，在方法中调用这个访问者对象的访问方法
         *
         * @param visitor
         */
        public void accept(Visitor visitor) {
            visitor.visit(this);
        }
    }

    /**
     * 第二步:定义一个用来访问组合模式复杂类的访问接口
     */
    public interface Visitor {
        void visit(Department dept);
    }

    /**
     * 第三步:定义一个 删除功能 访问者类 实现 访问接口
     */
    public static class RemoveVisitor implements Visitor {

        @Override
        public void visit(Department dept) {
            if (dept.getChildren().size() > 0) {
                for (Department child : dept.getChildren()) {
                    child.accept(this);
                }
            }
            System.out.println("删除部门【" + dept.getName() + "】");
        }
    }

    /**
     * 定义一个 修改状态功能 访问者类 实现 访问接口
     */
    public static class UpdateStatusVisitor implements Visitor {
        private String status;

        @Override
        public void visit(Department dept) {
            if (dept.getChildren().size() > 0) {
                for (Department child : dept.getChildren()) {
                    child.accept(this);
                }
            }
            System.out.println("将部门【" + dept.getName() + "】的状态修改为：" + status);
        }

        public UpdateStatusVisitor(String status) {
            this.status = status;
        }
    }

    public static void main(String[] args) {
        Department leafDept1 = new Department("叶子部门1");
        Department leafDept2 = new Department("叶子部门2");
        Department leafDept3 = new Department("叶子部门3");

        Department subDept1 = new Department("子部门1");
        subDept1.getChildren().add(leafDept1);
        subDept1.getChildren().add(leafDept2);

        Department subDept2 = new Department("子部门2");
        subDept2.getChildren().add(leafDept3);

        Department parentDept = new Department("父部门");
        parentDept.getChildren().add(subDept1);
        parentDept.getChildren().add(subDept2);

        // 新建一个删除访问者对象
        Visitor removeVisitor = new RemoveVisitor();
        // 使用 复杂对象的 accept方法 来调用 删除访问者对象 的方法
        parentDept.accept(removeVisitor);

        // 新建一个更新访问者对象
        Visitor updateStatusVisitor = new UpdateStatusVisitor("禁用");
        // 使用 复杂对象的 accept方法 来调用 更新访问者对象 的方法
        parentDept.accept(updateStatusVisitor);
    }
}
```

### 享元模式:

```java
import java.util.HashMap;
import java.util.Map;

/**
 * 享元模式:
 * 整个系统对同一个数据只存一份，整个系统全部享受一个对象实例
 * 
 */
public class FlyweightPatternDemo {
    
    /**
     * 第一步:定义抽象享元接口
     */
    public interface Flyweight {
        void execute();
        String getName();
        void setName(String name);
    }

    /**
     * 第二步:定义具体类来实现享元接口
     */
    public static class ConcreteFlyweight implements Flyweight {

        private String name;

        public ConcreteFlyweight(String name) {
            super();
            this.name = name;
        }

        @Override
        public String getName() {
            return name;
        }

        @Override
        public void setName(String name) {
            this.name = name;
        }

        @Override
        public void execute() {
            System.out.println(name + "执行功能逻辑");
        }
    }

    /**
     * 第三步:定义享元工厂类
     */
    public static class FlyweightFactory {

        private static Map<String, Flyweight> cachePool = new HashMap<String, Flyweight>();

        public static Flyweight get(String name) {
            Flyweight flyweight = cachePool.get(name);
            if (flyweight == null) {
                flyweight = new ConcreteFlyweight(name);
                cachePool.put(name, flyweight);
            }
            return flyweight;
        }
    }

    public static void main(String[] args) {
        Flyweight flyweight1 = FlyweightFactory.get("对象1");
        flyweight1.execute();

        Flyweight flyweight2 = FlyweightFactory.get("对象1");
        flyweight2.execute();

        System.out.println(flyweight1 == flyweight2);
    }
}
```

### 桥接模式:

```java
/**
 * 桥接模式:
 * 也就是面向接口编程，把接口作为两个代码组件之间的桥梁，java之中无处不桥接
 */
// implementor可以认为是一个代码组件，包含了一个接口和一个实现类
// abstraction可以认为是一个代码组件，包含了一个抽象类和一个子类
// abstraction要调用implementor的接口
// 在abstraction中包含了一个implementor的接口
// 在abstraction调用implementor的时候，实际上是面向implementor接口去编程和调用的
// 只不过我们会将implementor的实现类实例传入abstraction中

// abstraction调用implementor就是基于一个桥去调用的
// 不是说abstraction直接仅仅面向implementor实现类去编程的，面向implementor接口去编程的
// 所以abstraction和implementor两个代码组件之间的桥，就是implementor接口
// 这个一个代码组件面向另外一个代码组件的接口来编程，就是将那个接口作为一个桥
// 使用了桥接的设计模式来编程
public class BridgePatternDemo {

    public interface Implementor {
        void execute();
    }

    public static class ConcreteImplementor implements Implementor {

        @Override
        public void execute() {
            System.out.println("执行了功能逻辑");
        }
    }

    public static abstract class Abstraction {

        protected Implementor implementor;

        public Abstraction(Implementor implementor) {
            this.implementor = implementor;
        }

        public abstract void execute();

    }

    public static class RefinedAbstraction extends Abstraction {

        public RefinedAbstraction(Implementor implementor) {
            super(implementor);
        }

        @Override
        public void execute() {
            implementor.execute();
        }
    }

    public static void main(String[] args) {
        // ConcreteImplementor对象和 RefinedAbstraction 对象是由 Implementor 作为桥来协作的
        Implementor implementor = new ConcreteImplementor();
        Abstraction abstraction = new RefinedAbstraction(implementor);
        abstraction.execute();
    }
}
```

### 门面模式:

```java
/**
 * 不使用门面模式:
 * 带来的问题:
 * 1. 对于我们子系统2来说，编写业务逻辑需要去了解子系统1的模块结构，增加了维护成本
 * 2. 假如再有一个新功能 D 需要子系统1的模块功能，就需要复制粘贴代码，造成重复代码，
 */
public class WithoutFacadePatternDemo {

    /**
     * 子系统 1 模块A
     */
    public static class SystemOneModuleA {
        public void execute() {
            System.out.println("子系统1的模块A的功能");
        }
    }

    /**
     * 子系统 1 模块B
     */
    public static class SystemOneModuleB {
        public void execute() {
            System.out.println("子系统1的模块B的功能");
        }
    }

    /**
     * 子系统 1 模块C
     */
    public static class SystemOneModuleC {
        public void execute() {
            System.out.println("子系统1的模块C的功能");
        }
    }

    public static void main(String[] args) {
        // 假设我们是子系统2，现在要基于子系统1的3个模块的功能来实现一个业务逻辑
        SystemOneModuleA moduleA = new SystemOneModuleA();
        SystemOneModuleB moduleB = new SystemOneModuleB();
        SystemOneModuleC moduleC = new SystemOneModuleC();

        moduleA.execute();
        moduleB.execute();
        moduleC.execute();
    }
}
```

```java
/**
 * 门面模式:
 * 好处1: 抽象出一个子系统1门面类来统一封装功能逻辑，使用者只需要关注一个门面类即可，对使用者友好
 * 好处2: 高度抽象，统一维护，对修改友好
 */
public class FacadePatternDemo {

    /**
     * 第一步:定义子系统1中各模块功能
     */
    public static class ModuleA {
        public void execute() {
            System.out.println("子系统1的模块A的功能");
        }
    }

    public static class ModuleB {
        public void execute() {
            System.out.println("子系统1的模块B的功能");
        }
    }

    public static class ModuleC {
        public void execute() {
            System.out.println("子系统1的模块C的功能");
        }
    }

    /**
     * 第2步:
     * 统一定义1个门面类来封装子系统1中的多个模块组成的功能
     */
    public static class SystemOneFacade {

        public void execute() {
            // 子系统1，封装了自己的多个模块，ABC，基于自己多个模块的功能，对外统一暴露出去一个功能
            ModuleA moduleA = new ModuleA();
            ModuleB moduleB = new ModuleB();
            ModuleC moduleC = new ModuleC();

            moduleA.execute();
            moduleB.execute();
            moduleC.execute();
            System.out.println("新增的一段逻辑");
        }
    }

    public static void main(String[] args) {
        // 假设这里是子系统2，无需自己封装逻辑，只需要调用门面类封装的方法即可
        SystemOneFacade facade = new SystemOneFacade();
        facade.execute();
    }
}
```

### 构建者模式:

```java
import lombok.Data;

/**
 * 不使用构建者模式(在复杂对象构建场景中)
 * 如果有一个存在几十个字段甚至上百个字段的复杂对象要构建，面向过程的字段校验逻辑和设置属性值逻辑会十分复杂，
 * 会造成两个问题:
 * 1. 大量面条式代码堆积在一起，可读性差
 * 2. 如果有多个地方使用了这段逻辑，会出现重复代码。并且一旦需要修改，要同时在多个地方修改
 */
public class WithoutBuilderPatternDemo {

    /**
     * 第一步:存在一个构造逻辑复杂的类
     */
    @Data
    public static class Product {
        private String field1;
        private String field2;
        private String field3;
    }

    public static void main(String[] args) {
        // 想构造这个复杂的 product 对象时，只能把校验逻辑和设置属性值逻辑按面向过程思想来编写面条一样的代码
        Product product = new Product();

        System.out.println("在设置field1之前进行复杂的校验逻辑");
        // 设置field1属性
        product.setField1("值1");

        System.out.println("在设置field2之前进行复杂的数据格式转化逻辑");
        // 设置field2属性
        product.setField2("值2");

        System.out.println("在设置field3之前进行复杂的数据处理逻辑，跟其他对象的数据进行关联");
        // 设置field3属性
        product.setField3("值3");
    }
}
```

```java
import lombok.Data;

/**
 * 构建者模式:
 * 好处1: 通过定义builder接口来把复杂类的构建步骤拆分成多个部分，使代码逻辑清晰，提高了可维护性和可扩展性
 * 好处2: 通过定义Director类来把对象的构建过程封装在Director里面，如果构建逻辑需要修改，无需修改很多地方
 * 好处3: 抽象出Director和builder两个角色，相比工厂模式抽象程度更好
 */
public class BuilderPatternDemo {

    /**
     * 第一步:存在一个构建逻辑复杂的类
     */
    @Data
    public static class Product {
        private String field1;
        private String field2;
        private String field3;
    }

    /**
     * 第二步:针对复杂类定义一个构建接口 builder
     */
    public interface Builder {
        void field1(String value);

        void field2(String value);

        void field3(String value);

        Product build();
    }

    /**
     * 第三步:针对复杂类的构建接口 定义一个具体构建类
     * 具体构建类内部持有一个复杂对象
     */
    public static class ConcreteBuilder implements Builder {

        private Product product = new Product();

        @Override
        public void field1(String value) {
            System.out.println("在设置field1之前进行复杂的校验逻辑");
            product.setField1(value);
        }

        @Override
        public void field2(String value) {
            System.out.println("在设置field2之前进行复杂的数据格式转化逻辑");
            product.setField2(value);
        }

        @Override
        public void field3(String value) {
            System.out.println("在设置field3之前进行复杂的数据处理逻辑，跟其他对象的数据进行关联");
            product.setField3(value);
        }

        @Override
        public Product build() {
            return product;
        }

    }

    /**
     * 第四步:定义一个director类来面向builder的接口编程
     * director可以控制复杂构建的一个步骤，而具体的每个步骤的逻辑封装在具体的builder类中
     * 如果我们此时需要更换一整套的构建逻辑，可以再搞一个新的builder类就可以了
     * 但是对构建的逻辑是没有影响的
     */
    public static class Director {

        private Builder builder;

        public Director(Builder builder) {
            this.builder = builder;
        }

        public Product build(String field1, String field2, String field3) {
            builder.field1(field1);
            builder.field2(field2);
            builder.field3(field3);
            return builder.build();
        }
    }

    public static void main(String[] args) {
        Director director = new Director(new ConcreteBuilder());
        Product product = director.build("值1", "值2", "值3");
        System.out.println(product);
    }
}
```

```java
import lombok.Data;

/**
 * 优化后的 构建者模式:
 * 基本上现在流行的一些开源框架，构建者模式的运用都是使用的这种优化后的构建者模式
 */
public class OptimizedBuilderPatternDemo {
    /**
     * 第一步:存在一个构建逻辑复杂的类
     */
    @Data
    public static class Product {
        private String field1;
        private String field2;
        private String field3;
    }

    /**
     * 第二步:针对复杂类定义一个构建接口
     */
    public interface Builder {
        Builder field1(String value);

        Builder field2(String value);

        Builder field3(String value);

        Product build();
    }

    /**
     * 第三步:针对复杂类的构建接口 定义一个具体构建类
     * 具体构建类内部持有一个复杂对象
     */
    public static class ConcreteBuilder implements Builder {

        private Product product = new Product();

        @Override
        public Builder field1(String value) {
            System.out.println("在设置field1之前进行复杂的校验逻辑");
            product.setField1(value);
            return this;
        }

        @Override
        public Builder field2(String value) {
            System.out.println("在设置field2之前进行复杂的数据格式转化逻辑");
            product.setField2(value);
            return this;
        }

        @Override
        public Builder field3(String value) {
            System.out.println("在设置field3之前进行复杂的数据处理逻辑，跟其他对象的数据进行关联");
            product.setField3(value);
            return this;
        }

        @Override
        public Product build() {
            return product;
        }
    }

    public static void main(String[] args) {
        // 优化后的构造一个复杂对象的过程
        Product product = new ConcreteBuilder()
                .field1("值1")
                .field2("值2")
                .field3("值3")
                .build();
        System.out.println(product);
    }
}
```

### 中介者模式:

```java
/**
 * 不使用中介者模式:
 * 问题: 模块之间存在非常复杂的互相调用，互相严重耦合，其中一个模块修改代码，
 * 可能会影响其他模块的代码
 */
public class WithoutMediatorPatternDemo {

    /**
     * 存在一个模块A，需要调用模块B和模块C
     */
    public static class ModuleA {
        public void execute() {
            ModuleB moduleB = new ModuleB();
            ModuleC moduleC = new ModuleC();
            moduleB.execute("模块A");
            moduleC.execute("模块A");
        }

        public void execute(String invoker) {
            System.out.println(invoker + "在调用模块A的功能");
        }
    }

    /**
     * 存在一个模块B，需要调用模块A和模块C
     */
    public static class ModuleB {
        public void execute() {
            ModuleA moduleA = new ModuleA();
            ModuleC moduleC = new ModuleC();
            moduleA.execute("模块B");
            moduleC.execute("模块B");
        }

        public void execute(String invoker) {
            System.out.println(invoker + "在调用模块B的功能");
        }
    }

    /**
     * 存在一个模块C，需要调用模块A和模块B
     */
    public static class ModuleC {

        public void execute() {
            ModuleA moduleA = new ModuleA();
            ModuleB moduleB = new ModuleB();
            moduleA.execute("模块C");
            moduleB.execute("模块C");
        }

        public void execute(String invoker) {
            System.out.println(invoker + "在调用模块C的功能");
        }
    }

    public static void main(String[] args) {
        ModuleA moduleA = new ModuleA();
        ModuleB moduleB = new ModuleB();
        ModuleC moduleC = new ModuleC();

        // 调用模块A的功能
        moduleA.execute();
        // 调用模块B的功能
        moduleB.execute();
        // 调用模块C的功能
        moduleC.execute();
    }
}
```

```java
import lombok.Data;

/**
 * 中介者模式:
 * 好处:把模块A、模块B、模块C之间的相互调用逻辑封装在中介者类中，而对于模块A、模块B、模块C来说只要知道一个中介者即可，
 * 模块A 与模块B 与模块C之间不再存在任何耦合，任何一个模块修改逻辑都不会影响对方
 */
public class MediatorPatternDemo {

    /**
     * 第一步:定义一个中介者类，持有模块A、模块B、模块C的对象
     */
    @Data
    public static class Mediator {
        private ModuleA moduleA;
        private ModuleB moduleB;
        private ModuleC moduleC;

        public void moduleAInvoke() {
            moduleB.execute("模块A通知中介者");
            moduleC.execute("模块A通知中介者");
        }

        public void moduleBInvoke() {
            moduleA.execute("模块B通知中介者");
            moduleC.execute("模块B通知中介者");
        }

        public void moduleCInvoke() {
            moduleA.execute("模块C通知中介者");
            moduleB.execute("模块C通知中介者");
        }
    }

    /**
     * 第二步:定义一个模块A,内部只持有一个中介者对象，模块A的功能就是把执行委托给中介者对象去执行
     */
    public static class ModuleA {

        private Mediator mediator;

        public ModuleA(Mediator mediator) {
            this.mediator = mediator;
            this.mediator.setModuleA(this);
        }

        public void execute() {
            mediator.moduleAInvoke();
        }

        public void execute(String invoker) {
            System.out.println(invoker + "在调用模块A的功能");
        }
    }

    /**
     * 第二步:定义一个模块B,内部只持有一个中介者对象，模块B的功能就是把执行委托给中介者对象去执行
     */
    public static class ModuleB {

        private Mediator mediator;

        public ModuleB(Mediator mediator) {
            this.mediator = mediator;
            this.mediator.setModuleB(this);
        }

        public void execute() {
            mediator.moduleBInvoke();
        }

        public void execute(String invoker) {
            System.out.println(invoker + "在调用模块B的功能");
        }
    }

    /**
     * 第二步:定义一个模块C,内部只持有一个中介者对象，模块C的功能就是把执行委托给中介者对象去执行
     */
    public static class ModuleC {

        private Mediator mediator;

        public ModuleC(Mediator mediator) {
            this.mediator = mediator;
            this.mediator.setModuleC(this);
        }

        public void execute() {
            mediator.moduleCInvoke();
        }

        public void execute(String invoker) {
            System.out.println(invoker + "在调用模块C的功能");
        }
    }

    public static void main(String[] args) {
        // 创建一个中介者
        Mediator mediator = new Mediator();

        // 把中介者注入模块A
        ModuleA moduleA = new ModuleA(mediator);
        // 把中介者注入模块B
        ModuleB moduleB = new ModuleB(mediator);
        // 把中介者注入模块C
        ModuleC moduleC = new ModuleC(mediator);

        // 调用模块A的功能
        moduleA.execute();
        // 调用模块B的功能
        moduleB.execute();
        // 调用模块C的功能
        moduleC.execute();
    }
}
```

### 工厂模式:

```java
import lombok.Data;

/**
 * 不使用工厂模式:
 * 带来的问题:如果直接面向类来编程，使用new创建类实例，如果类的构造方法被修改，
 * 那么多处创建类实例的地方都需要修改代码，降低代码可维护性和可扩展性
 */
public class WithoutFactoryPatternDemo {

    /**
     * 存在一个普通类
     */
    @Data
    public static class Product {

        private String name;

        public Product(String name) {
            this.name = name;
        }
    }

    public static void main(String[] args) {
        // 直接面向类编程，使用new来创建类实例
        Product product = new Product("测试产品");
        System.out.println(product);
    }
}
```

```java
/**
 * 工厂模式: 用工厂类来封装对象的创建过程
 * 好处:如果之前有100个地方是使用工厂类来生产对象，
 * 当类实现逻辑改变时，只需要重新定义一个类来实现接口，
 * 并且只需要修改工厂类的创建对象逻辑即可，调用者无需修改代码
 */
public class FactoryPatternDemo {

    /**
     * 第一步:为工厂创建的所有类实例统一定义一个接口
     */
    public interface Product {
        void execute();
    }

    /**
     * 第二步:定义一个具体类来实现接口
     */
    public static class ProductImpl1 implements Product {
        @Override
        public void execute() {
            System.out.print("产品1的功能实现");
        }
    }

    /**
     * 第三步:定义一个工厂类来封装对象的创建过程
     */
    public static class ProductFactory {

        public static Product create() {
            return new ProductImpl1();
        }
    }

    /**
     * 当需求改变时，只需要重新定义一个类来实现接口，并修改工厂类的创建过程即可，无需调用者修改代码
     */
    public static class ProductImpl2 implements Product {
        @Override
        public void execute() {
            System.out.print("产品1的功能实现");
        }
    }

    public static void main(String[] args) {
        // 使用工厂来生产对象
        Product product = ProductFactory.create();
        product.execute();
    }
}
```

### 工厂方法模式:

```java
/**
 * 不使用工厂方法模式:
 * 问题:和模版方法模式的问题一样
 * 需要生产3种对象，定义了3种工厂类，但是工厂类内存在通用逻辑，
 * 没有抽取出来，而是通过复制粘贴的方式放在多个工厂类中，如果需要修改通用逻辑，
 * 需要在所有工厂中修改代码，修改的地方太多导致可能会忘记修改
 */
public class WithoutFactoryMethodPatternDemo {

    public interface Product {
        void execute();
    }

    public static class Product1 implements Product {
        @Override
        public void execute() {
            System.out.println("产品1的功能逻辑");
        }
    }

    public static class Product2 implements Product {
        @Override
        public void execute() {
            System.out.println("产品2的功能逻辑");
        }
    }

    public static class Product3 implements Product {
        @Override
        public void execute() {
            System.out.println("产品3的功能逻辑");
        }
    }

    public static class Product1Factory {

        public static Product createProduct() {
            System.out.println("生产产品的通用逻辑，修改");
            System.out.println("生产产品1的特殊逻辑");
            return new Product1();
        }
    }

    public static class Product2Factory {

        public static Product createProduct() {
            System.out.println("生产产品的通用逻辑，修改");
            System.out.println("生产产品2的特殊逻辑");
            return new Product2();
        }
    }

    public static class Product3Factory {

        public static Product createProduct() {
            System.out.println("生产产品的通用逻辑");
            System.out.println("生产产品3的特殊逻辑");
            return new Product3();
        }
    }

    public static void main(String[] args) {
        // 创建产品1对象
        Product product1 = Product1Factory.createProduct();
        // 创建产品2对象
        Product product2 = Product2Factory.createProduct();
        // 创建产品3对象
        Product product3 = Product3Factory.createProduct();

        // 调用产品1业务方法
        product1.execute();
        // 调用产品2业务方法
        product2.execute();
        // 调用产品3业务方法
        product3.execute();
    }
}
```

```java
/**
 * 工厂方法模式:
 * 定义一个抽象工厂类，封装通用逻辑，然后把特殊逻辑定义为抽象方法暴露给子类去实现
 * 好处:如果通用逻辑发生修改，只需要在抽象工厂类中修改一次即可，
 * 如果是特殊逻辑修改则只需要修改子类工厂实现即可
 */
public class FactoryMethodPatternDemo {

    /**
     * 定义一个工厂生产出来的产品接口
     */
    public interface Product {
        void execute();
    }

    /**
     * 定义类产品1实现接口
     */
    public static class Product1 implements Product {
        @Override
        public void execute() {
            System.out.println("产品1的功能逻辑");
        }
    }

    /**
     * 定义类产品2实现接口
     */
    public static class Product2 implements Product {
        @Override
        public void execute() {
            System.out.println("产品2的功能逻辑");
        }
    }

    /**
     * 定义类产品3实现接口
     */
    public static class Product3 implements Product {
        @Override
        public void execute() {
            System.out.println("产品3的功能逻辑");
        }
    }

    /**
     * 第2步:定义一个抽象工厂类，封装通用逻辑，
     * 并把特殊逻辑通过抽象方法暴露给子类去实现
     */
    public static abstract class AbstractProductFactory {

        public Product createProduct() {
            commonCreate();
            return specificCreate();
        }

        private void commonCreate() {
            System.out.println("生产产品的通用逻辑，修改");
        }

        protected abstract Product specificCreate();

    }

    /**
     * 第3步:定义具体工厂类 继承 抽象工厂类
     * 并覆写特殊逻辑方法
     */
    public static class Product1Factory extends AbstractProductFactory {

        private static final Product1Factory instance = new Product1Factory();

        private Product1Factory() {
        }

        public static Product1Factory get() {
            return instance;
        }

        @Override
        public Product specificCreate() {
            System.out.println("生产产品1的特殊逻辑");
            return new Product1();
        }
    }

    public static class Product2Factory extends AbstractProductFactory {

        private static final Product2Factory instance = new Product2Factory();

        private Product2Factory() {
        }

        public static Product2Factory get() {
            return instance;
        }

        @Override
        public Product specificCreate() {
            System.out.println("生产产品2的特殊逻辑");
            return new Product2();
        }
    }

    public static class Product3Factory extends AbstractProductFactory {

        private static final Product3Factory instance = new Product3Factory();

        private Product3Factory() {
        }

        public static Product3Factory get() {
            return instance;
        }

        @Override
        public Product specificCreate() {
            System.out.println("生产产品3的特殊逻辑");
            return new Product3();
        }
    }

    public static void main(String[] args) {
        Product product1 = Product1Factory.get().createProduct();
        Product product2 = Product2Factory.get().createProduct();
        Product product3 = Product3Factory.get().createProduct();

        product1.execute();
        product2.execute();
        product3.execute();
    }
}
```

### 抽象工厂模式:

```java
/**
 * 不使用抽象工厂模式:
 */
public class WithoutAbstractFactoryPatternDemo {

    public interface ProductA {
        void execute();
    }

    public static class ProductA1 implements ProductA {
        @Override
        public void execute() {
            System.out.println("产品A1的功能逻辑");
        }
    }

    public static class ProductA2 implements ProductA {
        @Override
        public void execute() {
            System.out.println("产品A2的功能逻辑");
        }
    }

    public static class ProductA3 implements ProductA {
        @Override
        public void execute() {
            System.out.println("产品A3的功能逻辑");
        }
    }

    public interface ProductB {
        void execute();
    }

    public static class ProductB1 implements ProductB {
        @Override
        public void execute() {
            System.out.println("产品B1的功能逻辑");
        }
    }

    public static class ProductB2 implements ProductB {
        @Override
        public void execute() {
            System.out.println("产品B2的功能逻辑");
        }
    }

    public static class ProductB3 implements ProductB {
        @Override
        public void execute() {
            System.out.println("产品B3的功能逻辑");
        }
    }

    public static void main(String[] args) {
        // 我们现在需要 产品A1 + 产品B1 的组合
		ProductA productA1 = new ProductA1();
		ProductB productB1 = new ProductB1();

		productA1.execute();
		productB1.execute();

        // 现在变成需要创建 产品A1 + 产品B3 的组合
        ProductA productA1 = new ProductA1();
        ProductB otherProductB3 = new ProductB3();

        productA1.execute();
        otherProductB3.execute();

        /**
         * 带来的问题就是，调整产品组合这个行为是由调用者来组合的，如果产品组合逻辑发生改变，
         * 只能由调用者手动修改逻辑，如果多处使用只能到处修改，不可维护且不可扩展
         */

        // 我们现在需要 产品A2 + 产品B2 的组合，只能
        ProductA productA2 = new ProductA2();
        ProductB productB2 = new ProductB2();

        productA2.execute();
        productB2.execute();

        // 我们现在需要 产品A3 + 产品B3 的组合
        ProductA productA3 = new ProductA3();
        ProductB productB3 = new ProductB3();

        productA3.execute();
        productB3.execute();
    }
}
```

```java
/**
 * 抽象工厂模式:
 * 对不同的产品组合在工厂内进行封装
 */
public class AbstractFactoryPatternDemo {

    /**
     * 第1步:定义A产品接口
     */
    public interface ProductA {
        void execute();
    }

    /**
     * 具体产品A1
     */
    public static class ProductA1 implements ProductA {
        @Override
        public void execute() {
            System.out.println("产品A1的功能逻辑");
        }
    }

    /**
     * 具体产品A2
     */
    public static class ProductA2 implements ProductA {
        @Override
        public void execute() {
            System.out.println("产品A2的功能逻辑");
        }
    }

    /**
     * 具体产品A3
     */
    public static class ProductA3 implements ProductA {
        @Override
        public void execute() {
            System.out.println("产品A3的功能逻辑");
        }
    }

    /**
     * 定义B产品接口
     */
    public interface ProductB {
        void execute();
    }

    /**
     * 具体产品B1
     */
    public static class ProductB1 implements ProductB {
        @Override
        public void execute() {
            System.out.println("产品B1的功能逻辑");
        }
    }

    /**
     * 具体产品B2
     */
    public static class ProductB2 implements ProductB {
        @Override
        public void execute() {
            System.out.println("产品B2的功能逻辑");
        }
    }

    /**
     * 具体产品B3
     */
    public static class ProductB3 implements ProductB {
        @Override
        public void execute() {
            System.out.println("产品B3的功能逻辑");
        }
    }

    /**
     * 第2步:针对A产品和B产品定义一个工厂接口，用于生产A产品和B产品
     */
    public interface Factory {
        ProductA createProductA();

        ProductB createProductB();
    }

    /**
     * 第3步:定义一个工厂1实现工厂接口，来生产 A1产品+ B3产品
     */
    public static class Factory1 implements Factory {

        private static final Factory1 instance = new Factory1();

        private Factory1() {
        }

        public static Factory get() {
            return instance;
        }

        @Override
        public ProductA createProductA() {
            return new ProductA1();
        }

        @Override
        public ProductB createProductB() {
            return new ProductB1();
        }
    }

    /**
     * 定义一个工厂2实现工厂接口，来生产 A2产品+ B2产品
     */
    public static class Factory2 implements Factory {

        private static final Factory2 instance = new Factory2();

        private Factory2() {
        }

        public static Factory get() {
            return instance;
        }

        @Override
        public ProductA createProductA() {
            return new ProductA2();
        }

        @Override
        public ProductB createProductB() {
            return new ProductB2();
        }

    }

    /**
     * 定义一个工厂2实现工厂接口，来生产 A3产品+ B3产品
     */
    public static class Factory3 implements Factory {

        private static final Factory3 instance = new Factory3();

        private Factory3() {
        }

        public static Factory get() {
            return instance;
        }

        @Override
        public ProductA createProductA() {
            return new ProductA3();
        }

        @Override
        public ProductB createProductB() {
            return new ProductB3();
        }
    }

    public static void main(String[] args) {
        // 产品A1 + 产品B1 -> 变成需要产品A1 + 产品B3，只需要修改工厂1的生产B产品方法即可，无需调用者修改代码
        ProductA firstProductA = Factory1.get().createProductA();
        ProductB firstProductB = Factory1.get().createProductB();
        firstProductA.execute();
        firstProductB.execute();

        // 变成需要产品A2 + 产品B2
        ProductA secondProductA = Factory2.get().createProductA();
        ProductB secondProductB = Factory2.get().createProductB();
        secondProductA.execute();
        secondProductB.execute();

        // 变成需要产品A3 + 产品B3
        ProductA thirdProductA = Factory3.get().createProductA();
        ProductB thirdProductB = Factory3.get().createProductB();
        thirdProductA.execute();
        thirdProductB.execute();
        // 哪怕有100个地方定义了产品组合，要调整组合的逻辑，只要修改一个工厂就可以了
    }
}
```

### 备忘录模式:

```java
/**
 * 备忘录模式:
 * 面向场景:系统中生产出一份中间数据，在系统中的好几个方法都需要基于这份中间数据去处理，
 * 在每个方法处理过程中可能会修改中间数据，这时下一个方法再处理时数据已经发生了变化导致出错，
 * 所以必须通过备忘录的方式把中间数据暂存一份，然后后面的方法需要中间数据时，
 * 直接从备忘录中将中间数据恢复出来再执行后面的操作
 */
public class MementoPatternDemo {

    /**
     * 第1步: 定义一个备忘录接口
     */
    public interface Memento {
    }

    /**
     * 第2步:定义一个原发器类，负责创建备忘录
     */
    public static class Originator {

        private String state;

        public void prepare() {
            this.state = "中间数据";
        }

        public void executeA() {
            System.out.println("基于中间数据【" + state + "】执行了A方法的逻辑");
            // 将state所代表的中间数据做出了修改
            state += "，A方法的结果数据";
        }

        public void executeB() {
            System.out.println("基于中间数据【" + state + "】执行了B方法的逻辑");
            state += "，B方法的结果数据";
        }

        public Memento createMemento() {
            return new MementoImpl(state);
        }

        public void setMemento(Memento memento) {
            MementoImpl mementoImpl = (MementoImpl) memento;
            this.state = mementoImpl.getState();
        }

        /**
         * 备忘录实现类
         */
        private static class MementoImpl implements Memento {

            private String state;

            public MementoImpl(String state) {
                this.state = state;
            }

            public String getState() {
                return state;
            }
        }
    }

    /**
     * 第3步: 定义一个(看守人)类，负责保存备忘录
     */
    public static class Caretaker {

        private Memento memento;

        public void saveMemento(Memento memento) {
            this.memento = memento;
        }

        public Memento retrieveMemento() {
            return this.memento;
        }
    }

    public static void main(String[] args) {
        // 创建一个原发器
        Originator originator = new Originator();
        // 准备中间数据
        originator.prepare();
        // 针对中间数据创建备忘录
        Memento memento = originator.createMemento();
        // 将备忘录保存到备忘录管理器中去
        Caretaker caretaker = new Caretaker();
        caretaker.saveMemento(memento);

        // 基于中间数据执行了A方法，但是此时中间数据已经改变了
        originator.executeA();

        // 从备忘录管理器中获取备忘录
        memento = caretaker.retrieveMemento();
        // 将备忘录中保存好的中间数据重新设置到原发器中去，就将中间数据恢复成了之前备忘的状态
        originator.setMemento(memento);
        // 接着再次执行方法B
        originator.executeB();
    }
}
```

### 适配器模式:

```java
/**
 * 不用适配器模式的实现:
 * 需求: 之前已经写好了老接口，还有一个老接口的实现类，现在需要重新定一套新接口，并编写新接口实现类
 * 问题: 想要不使用适配器模式来实现的话，由于新老接口不兼容，只能是重新写一个新接口的实现类，
 * 所以老接口实现类在新接口实现类中用不上，造成只能同时维护两套风格和规范完全不同的接口，提高了理解维护成本
 */
public class WithoutAdapterPatternDemo {

    /**
     * 老版本接口
     */
    public interface OldInterface {
        void oldExecute();
    }

    /**
     * 老版本接口的实现类
     */
    public static class OldInterfaceImpl implements OldInterface {
        @Override
        public void oldExecute() {
            System.out.println("老版本接口实现的功能逻辑");
        }
    }

    /**
     * 新版本接口
     */
    public interface NewInterface {
        void newExecute();
    }

    /**
     * 新版本接口的实现类
     */
    public static class NewInterfaceImpl implements NewInterface {
        @Override
        public void newExecute() {
            System.out.println("新版本接口实现的功能逻辑");
        }
    }

    public static void main(String[] args) {
        OldInterface oldObject = new OldInterfaceImpl();
        NewInterface newObject = new NewInterfaceImpl();
        oldObject.oldExecute();
        newObject.newExecute();
    }
}
```

```java
/**
 * 适配器模式:
 * 目前手上有新老两个接口和一个老接口实现类，但是系统现在需要面向新接口开发，老接口的实现类就没法用了，
 * 所以定义一个适配器类来实现新接口，并在类内部持有一个老接口实现类的实例引用，适配器类中对新接口方法的实现，
 * 全部基于老接口实现类的老方法来实现即可。这样对于调用方而言，还是面向新接口来开发，无需关心新接口的实现，
 * 实际上调用方使用的新接口实现是由适配器类完成的
 */
public class AdapterPatterDemo {

    /**
     * 第1步:
     * 定义一个适配器类实现新接口，并在类内部持有一个老接口实现类的实例，适配器类中的新接口方法全部基于老接口实现类的老方法实现即可
     */
    public static class NewInterfaceAdapter implements NewInterface {

        private OldInterface oldObject;

        public NewInterfaceAdapter(OldInterface oldObject) {
            this.oldObject = oldObject;
        }

        @Override
        public void newExecute() {
            oldObject.oldExecute();
        }
    }

    /**
     * 老版本接口
     */
    public interface OldInterface {
        void oldExecute();
    }

    /**
     * 老版本接口的实现类
     */
    public static class OldInterfaceImpl implements OldInterface {
        @Override
        public void oldExecute() {
            System.out.println("老版本接口实现的功能逻辑");
        }
    }

    /**
     * 新版本接口
     */
    public interface NewInterface {
        void newExecute();
    }

    /**
     * 新版本接口的实现类
     */
    public static class NewInterfaceImpl implements NewInterface {
        @Override
        public void newExecute() {
            System.out.println("新版本接口实现的功能逻辑");
        }
    }

    public static void main(String[] args) {
        NewInterface oldObject = new NewInterfaceAdapter(new OldInterfaceImpl());
        NewInterface newObject = new NewInterfaceImpl();
        oldObject.newExecute();
        newObject.newExecute();
    }
}
```

### 单例模式:

#### 饿汉模式:

```java
/**
 * 饿汉模式: 非常饥饿，直接创建对象
 * 指全局的单例实例在类装载时创建。
 * 问题:直接初始化，可能会造成浪费空间
 */
public class HungrySingletonPatternDemo {

    public static class Singleton {

        /**
         * 第 1 步：直接将类的实例创建出来，赋予static final修饰的变量
         * <p>
         * static：就是一个类的静态变量
         * final：这个变量的引用第一次初始化赋予之后，就再也不能修改引用了
         */
        private static final Singleton instance = new Singleton();

        /**
         * 第 2 步：将构造函数搞成private私有的，防止被外部创建实例,
         * 此时除了这个类自己本身，其他任何人都不能创建它的实例对象
         */
        private Singleton() {}

        /**
         * 第 3 步：给一个static静态方法，返回自己内部创建的唯一一个实例
         */
        public static Singleton getInstance() {
            return instance;
        }

        public void execute() {
            System.out.println("单例类的方法");
        }
    }

    public static void main(String[] args) {
        Singleton singleton = Singleton.getInstance();
        singleton.execute();
    }
}
```

#### 线程不安全的饱汉模式:

```java
/**
 * 线程不安全的饱汉模式
 */
public class UnsafeFullSingletonPatternDemo {
	/**
	 * 线程不安全
	 */
	public static class Singleton {
		
		private static Singleton instance;
		
		private Singleton() {}
		
		public static Singleton getInstance() {
			/*
			 * 假设有两个线程过来
			 * 
			 * 线程的基础：线程是并发着执行的，cpu，先执行一会儿线程1，然后停止执行线程1；切换过去执行线程2
			 * 执行线程2一会儿之后，再停止执行线程2；回来继续执行线程1
			 * 
			 * 第一个线程，判断发现说instance == null，代码就进入到了下面去
			 * 第二个线程，执行到这儿，发现，此时instance == null，那么就没什么问题了，继续往下走
			 * 
			 */
			if(instance == null) {
				// 第一个线程跑到了这儿来，但是此时第一个线程，还没有执行下面的那行代码
				// 此时，第二个线程代码也执行到了这儿，cpu切换回线程1
				
				// 执行线程1的代码，线程1会创建一个实例出来
				// 但是切换到线程2去执行的时候，线程2,的代码已经执行到这儿来了，此时又会再一次执行下面的代码
				// 就是会再一次创建一个实例，之前线程1创建的那个实例，就会被垃圾回收，废弃掉了
				
				instance = new Singleton();
			}
			return instance;
		}
	}
}
```

#### 线程安全的饱汉模式:

双重检查锁 + volatile

```java
/**
 * 用volatile禁止指令重排的原因:
 * java中新建对象不是一个原子操作，而是分为三步:
 * (1)分配内存空间
 * (2)执行类构造方法，初始化对象
 * (3)把对象引用指向内存空间
 * 而在某些编译器中(2)和(3)是可以重排序的，如果发生了重排序，当线程A执行到new lazy()来创建对象时，按(1)(3)(2)的顺序
 * 执行，当执行完(1)(3)时，线程B执行getInstant()方法时会判断lazy引用不是空的，然后直接返回lazy，这时的lazy还没有被
 * 初始化，导致返回null。用volatile禁止new Lazy()的指令重排序
 */
public class SafeFullSingleton {
    private static volatile SafeFullSingleton instance = null;

    // 私有化构造器，防止被类实例被外部创建
    private SafeFullSingleton() {}

    public static SafeFullSingleton getInstant() {
        // 如果线程1和线程2都执行到了这一步，然后此时线程1判断发现还是null
        // 线程2此时判断发现instance == null，也会进去
        if (instance == null) {
            // 线程1就会进来，此时线程1停止，切换到线程2
            // 线程2也会进来，此时切换到线程1

            // 线程1，发现这里需要加锁， 在这里加锁，获取到了这个锁
            // 线程2过来，线程2发现说，我也想要在这里加锁，发现说这个锁被人加了，线程2挂起等待别人释放锁
            // 此时切换回线程2，线程2发现锁被释放，然后在这里加锁
            synchronized (SafeFullSingleton.class) {
                // 线程1就进来了，此时切换到线程2
                // 切换回线程1，线程1此时在这里，再次判断，instance == null
                // 线程2就进来了，double check，如果这里没有instance == null的判断，那么线程2就会再次创建
                // 一个实例
                // 但是这里是双重检查，线程2又判断了一下，instance == null？否，不是null
                if (instance == null) {
                    // 线程1就会进来，创建一个实例 (java中新建对象不是一个原子操作)
                    instance = new SafeFullSingleton();
                    return instance;
                }
            }
        }
        // 这边出来以后，线程1就释放锁了
        // 线程2跳出来，直接获取一个instance返回了，这个instance就是之前线程1创建的实例
        return instance;
    }
}
```

#### 使用内部类:

```java
/**
 * 静态内部类模式: 利用JVM的类加载机制特性来保证全局单例
 * 这个才是我们实际开发过程中，最最常用的单例模式，用内部类的方式来实现
 */
public class InnerClassFullSingletonPatternDemo {

	/**
	 * 可以做饱汉模式
	 * 
	 * 内部类，只要没有被使用就不会初始化，Singleton的实例就不会创建
	 * 在第一次有人调用getInstance方法的时候，内部类会初始化，创建一个Singleton的实例
	 * 然后jvm能确保类静态初始化的过程一定只会执行一次
	 */
	public static class Singleton {
		// 私有化构造器，防止被外部创建对象。这样就只能通过调用静态方法的方式使用此类了
		private Singleton() {}

		// 定义一个内部类 InnerHolder 用来持有单例类实例。并且单例类实例只允许被该内部类所持有
		public static class InnerHolder {
			public static final Singleton instance = new Singleton();
		}

		// 对外暴露一个静态方法来获取实例
		public static Singleton getInstance() {
			return InnerHolder.instance;
		}
	}
}
```

#### 使用枚举:

```java
public class UcUser {
    // 私有化构造器
    private UcUser() {
    }

    enum SingleTonEnum {
        // 创建一个枚举对象，该对象天生为单例
        Instant;
        private UcUser ucUser;

        SingleTonEnum() {
            ucUser = new UcUser();
        }

        public UcUser getInstant() {
            return ucUser;
        }
    }

    // 对外暴露一个获取user的方法
    public static UcUser getInstance() {
        return SingleTonEnum.Instant.getInstant();
    }

    public static void main(String[] args) {
        System.out.println(UcUser.getInstance().equals(UcUser.getInstance()));
        // 运行结果: true
    }
}
```









































### 1. 动态代理:

用场景举例:有个叫IHelloWorld接口及其实现类HelloWorld，它有一个叫sayHello()的方法。现在需要在sayHello()之前和之后，额外加一些日志的输出。  
两种方式实现：(1)手动写一个类HelloWorldEx
```
public class HelloWorldEx implements IHelloWorld {
    IHelloWorld hw;

    public HelloWorldEx(IHelloWorld hw) {
        this.hw = hw;
    }

    public void sayHello() {
        Logger.startLog();
        hw.sayHello();
        Logger.endLog();
    }
}
```
(2) 有个接口(IHelloWorld)及其实现类(HelloWorld)， 然后有个InvocationHandler的实现，最后用Proxy.newProxyInstance(....)创建一个新的类出来。  

那么手动写一个类HelloWorldEx和用Proxy.newProxyInstance来创建，有什么区别呢？  
实现的功能是相同的，但是HelloWorldEx需要事先写好，编译后不能改了，相当于写死了！如果我想对Order类，Employee类，Department类，也想加点儿日志，还得写个OrderEx，EmployeeEx，DepartmentEx的类，太麻烦了！
而Proxy.newProxyInstance这种方法，可以在程序运行的时候为任意类动态地创建增强的类。
事先写死的叫做静态代理，Proxy.newProxyInstance这种方式叫做动态代理，更加灵活。  

那么为什么要创建新的代理类，那个Proxy.newProxyInstance不能直接修改老的HelloWorld类吗？  
Java本质是一个静态类型的语言，class一旦被装入JVM，是不能修改`添加`删除方法的，那么既然老的class不能修改，就只能通过代理的方式来创建新的类了。  
动态代理主要应用场景:记日志，安全方面。具体功能主要由aop来实现。AOP中经常会以声明的方式提出这样的要求：某个包下所有add开头的方法，在执行之前都要调用Logger.startLog()方法，
在执行之后都要调用Logger.endLog()方法。或者对于所有以Service结尾的类，所有的方法执行之前都要调用tx.begin()，执行之后都要调用tx.commit(), 如果抛出异常的话调用tx.rollback()。  

AOP中经常有这样的需求......  ，Spring想添加这些日志和事务的功能，但是却没有办法去修改用户的类，它是框架啊，一是不知道用户类的源码，二是Java不允许再修改装载入JVM的class。
没办法，Spring只好在运行时找到用户的类，然后操作字节码动态创建一个新类，新类会对原有的类进行增强，添加日志，事务这些功能，注意啊，这些都是在内存中动态创建的。
这就是JDK的动态代理，不过它有个前提要求，就是用户的类需要实现接口才行。  

CgLib提供了另外一种对现有类增强的办法，动态生成的类继承了现有的类，两者是“父子关系”。  

