### 进程间是如何通信的？线程间又如何切换呢？
* 这个问题不是高频问题，但确实可能会被问到，因为计算机基础就是网络，cpu，磁盘，内存，进程，这点东西，所以可能问这个问题来考察基础知识怎么样。

进程间通信方式有很多种，比如:管道(pipe)、命名管道(fifo)、消息队列、共享内存(System V)
* 管道(pipe):在linux操作系统里，管道是一个固定大小的缓冲区，是4
kb，用来缓存要在进程间传输的数据。
linux底层对管道的实现: 是用了两个文件，指向了一个VFS(虚拟文件系统)的索引节点inode,然后VFS索引节点指向一个物理页面，接着一个进程通过自己关联的那个文件写数据，另一个进程通过自己关联的那个文件读数据

管道中的数据一旦被读取出来就不在管道里了。如果管道满了，那么写管道的操作就阻塞了，直到别人读取了管道的数据；反之如何管道是空的，那么读操作就阻塞了。管道一边连着一个进程的输出，一边连着一个进程的输入；然后一个进程写数据，另一个进程读数据，当两个进程都没了时，管道也就没了。管道是半双工的，也就是数据只能流向一个方向，比如你架设一个管道，那么只能一个进程写，另一个进程读。

管道机制要求两个两个进程之间必须有血缘关系，比如fork出来的父子进程才可以使用管道。unix操作系统中，有一个fork操作，可以创建进程的子进程，或者说是复制一个和父进程完全一样的子进程，父进程和子进程共享代码空间，但是各自有独立的数据空间，不过子进程的数据空间是拷贝父进程的数据空间的。
* 命名管道(fifo):前面的管道通信要求必须是父子关系的进程才可以通信，进程间通信受到了限制，所以引出命名管道来解决这个问题。
之前的管道是没有名字的，所以必须是有父子关系的进程才可以使用这种方式通信。而命名管道是有名字的，这个命名管道相当于是一个有名字的文件，是有有路径的，所以没有血缘关系的进程也可以通过命名管道来通信，名字在文件系统上，数据在内存里。其他的特性和管道一样，一个进程写，一个进程读，也是半双工的，数据只能单向流动。
* 消息队列: linux的消息队列是链表结构，linux内核有一个msgque链表，这个链表里每个指针指向一个msgid_ds
结构，这个结构就描述了一个消息队列。进程间通过这个消息队列来通信，一样是写入数据和消费数据。消息队列的好处就是对每个消息可以指定类型，消费的时候可以消费指定类型的消息，这种方式用的不多。
* 共享内存: 一块物理内存被映射到两个进程的进程地址空间，这两个进程互相都可以看到对方在共享内存里做出的修改，所以在修改共享内存时需要用锁来同步，防止对方将更新覆盖

* 线程间如何切换:一个进程的多个线程间切换时涉及到了上下文切换。基于时间片算法，cpu
给每个线程一个时间片来执行，时间片结束后，保存这个线程的上下文状态，然后切换到下一个线程去执行，这就是多线程并发执行的原理，也就是多个线程来回切换轮流执行，每个线程在一个时间片里执行