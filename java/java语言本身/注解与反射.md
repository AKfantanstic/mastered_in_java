#### 注解

注解是jdk1.5开始引入的新功能

##### 注解有什么用？

可以被其他程序读取(比如编译器)

##### 注解可以用在哪里？

package、class、method、field。并且可以通过反射来访问注解上的信息

##### 什么是元注解？

java定义了4个标准的元注解类型，用于解释其他注解

* @Target: 描述注解的使用范围(type、field、method、parameter、constructor、package)
* @Retention: 注解的注释保存级别(runtime>class>source)
* @Document: 用于生成javadoc
* @Inherited:此注解可以被子类继承

##### 自定义注解

使用@interface来自定义注解,默认自动继承了java.lang.annotation.Annotation接口

```java
import java.lang.annotation.ElementType;
import java.lang.annotation.Target;

public class TestAnnotation {
    // 注解参数如果没有默认值，则必须显式赋值，否则编译报错
    @MyAnnotation(name = "zhangsan")
    public void test() {
    }
}

@Target({ElementType.METHOD, ElementType.TYPE})
@interface MyAnnotation {
    // 参数类型 + 参数名: 注解参数，如果参数不是必填的可以设置一个默认值
    String name() default "";

    String[] schools() default {"清华", "北大"};

    // 如果注解只有一个参数，建议参数名为value，这时注解可以不写value=，可以直接填值
    String value() default "";
}
```

#### 反射

动态语言指的是运行时可以修改自身结构，比如增删方法、增删字段。c、c++、java都是静态类型语言(运行时结构不可变)，但是java的反射机制使它具有一定的动态性，能获得类似动态语言的特性。

反射机制允许程序在运行时借助Reflection包下的工具取得任何类的内部信息，并可以直接操作字段和方法。通过一个对象的getClass()方法获取到类的class对象，这个class对象就像一面镜子，透过这个镜子能看到类的完整结构，所以形象的称之为“反射”

##### 反射的优点和缺点

###### 优点

可以动态创建对象，带来很多灵活性

###### 缺点

由于反射是一种解释操作，这类操作慢于直接执行相同的操作，所以对性能有影响

##### 反射相关api:

* java.lang.Class:表示一个类
* java.lang.reflcect.Method: 表示类的方法
* java.lang.reflect.Field: 表示类的成员变量
* java.lang.reflect.Constructor: 表示类构造器

Object类中的getClass()方法返回的是一个Class类，Class类是Java反射的源头，也就是说可以通过对象反射求出类的名称。对象照镜子后可以得到的信息:某个类的成员变量、方法、构造器

想用反射，必须先获得对应的Class对象

##### 如何获取class类的实例

``` bash
# 1.已知具体类，可以通过类的class属性获取,这种方法最安全可靠，程序性能最高
Class clazz = Person.class

# 2. 通过某个对象的getClass()方法获取
Class clazz = person.getClass();

# 3. 通过类的全限定名加载
Class clazz = Class.forName("com.ak.juc.person");

# 如果是内置的基本类型可以使用“基本类型的类名.Type”来获取
Class clazz = Integer.Type;

# 利用ClassLoader
```

##### 都有哪些类有class对象？

```bash
class: 类
interface: 接口
[]: 数组
enum: 枚举
annotation: 注解
primitive type: 基本数据类型
void
```

##### 类加载器

```java
public class ClassLoaderDemo {
    public static void main(String[] args) throws ClassNotFoundException {
        // 获取系统类加载器
        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
        System.out.println("当前系统类加载器为: " + systemClassLoader);
        // 获取系统类加载器的父类加载器 -> 扩展类加载器
        ClassLoader parent = systemClassLoader.getParent();
        System.out.println("系统类加载器的父类为: " + parent);
        // 获取扩展类加载器的父类加载器
        ClassLoader parent1 = parent.getParent();
        System.out.println("扩展类加载器的父类为 " + parent1);
        // 测试当前类是谁加载的
        ClassLoader currentClassLoader = Class.forName("com.example.juc.ClassLoaderDemo").getClassLoader();
        System.out.println("当前类是由 " + currentClassLoader + " 加载的");
        //  测试 JDK 内置类是谁加载的
        ClassLoader jdkInnerClassLoader = Class.forName("java.lang.Object").getClassLoader();
        System.out.println("jdk内置的Object类是由 " + jdkInnerClassLoader + " 加载的");
    }
}
```

```bash
# 运行结果:
当前系统类加载器为: sun.misc.Launcher$AppClassLoader@18b4aac2
系统类加载器的父类为: sun.misc.Launcher$ExtClassLoader@4f3f5b24
扩展类加载器的父类为 null
当前类是由 sun.misc.Launcher$AppClassLoader@18b4aac2 加载的
jdk内置的Object类是由 null 加载的
```



##### 获取运行时类的完整结构

通过反射获取运行时类的完整结构:

Field、Method、Constructor、Superclass、Interface、Annotation

实现的全部接口

所继承的父类

全部的构造器

全部方法

全部fiedl

注解

```java
public class ClassInfoDemo {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException {
        Class userClass = Class.forName("com.example.juc.User");
        // 获得类全限定名
        System.out.println("类全限定名为: " + userClass.getName());
        // 获得类名
        System.out.println("类名为: " + userClass.getSimpleName());

        // 获得类的属性(只能找到public权限的属性)
        Field[] fields = userClass.getFields();
        System.out.println("========= 类中public的属性为 =========");
        for (Field field : fields) {
            System.out.println(field);
        }
        // 获得类的属性(找到全部属性)
        fields = userClass.getDeclaredFields();
        System.out.println("======== 类中的全部属性为 ==========");
        for (Field field : fields) {
            System.out.println(field);
        }
        System.out.println("======== 获取指定属性值 ==========");
        // 获取指定属性值(所有权限的属性)
        Field name = userClass.getDeclaredField("name");
        System.out.println("getDeclaredField()  ->  "+name);
        // 获取指定属性值(只能获取public权限的属性)
        name = userClass.getField("name");
        System.out.println("getField()  ->  "+name);
    }
}
```

```bash
# 运行结果:
类全限定名为: com.example.juc.User
类名为: User
========= 类中public的属性为 =========
======== 类中的全部属性为 ==========
private java.lang.String com.example.juc.User.name
private java.lang.Integer com.example.juc.User.age
======== 获取指定属性值 ==========
getDeclaredField()  ->  private java.lang.String com.example.juc.User.name
Exception in thread "main" java.lang.NoSuchFieldException: name
```

























