#### 注解

注解是jdk1.5开始引入的新功能

##### 注解有什么用？

可以被其他程序读取(比如编译器)

##### 注解可以用在哪里？

package、class、method、field。并且可以通过反射来访问注解上的信息

##### 什么是元注解？

java定义了4个标准的元注解类型，用于解释其他注解

* @Target: 描述注解的使用范围(type、field、method、parameter、constructor、package)
* @Retention: 注解的注释保存级别(runtime>class>source)
* @Document: 用于生成javadoc
* @Inherited:此注解可以被子类继承

##### 自定义注解

使用@interface来自定义注解,默认自动继承了java.lang.annotation.Annotation接口

```java
import java.lang.annotation.ElementType;
import java.lang.annotation.Target;

public class TestAnnotation {
    // 注解参数如果没有默认值，则必须显式赋值，否则编译报错
    @MyAnnotation(name = "zhangsan")
    public void test() {
    }
}

@Target({ElementType.METHOD, ElementType.TYPE})
@interface MyAnnotation {
    // 参数类型 + 参数名: 注解参数，如果参数不是必填的可以设置一个默认值
    String name() default "";

    String[] schools() default {"清华", "北大"};

    // 如果注解只有一个参数，建议参数名为value，这时注解可以不写value=，可以直接填值
    String value() default "";
}
```

#### 反射

动态语言指的是运行时可以修改自身结构，比如增删方法、增删字段。c、c++、java都是静态类型语言(运行时结构不可变)，但是java的反射机制使它具有一定的动态性，能获得类似动态语言的特性。

反射机制允许程序在运行时借助Reflection包下的工具取得任何类的内部信息，并可以直接操作字段和方法。通过一个对象的getClass()方法获取到类的class对象，这个class对象就像一面镜子，透过这个镜子能看到类的完整结构，所以形象的称之为“反射”

##### 反射的优点和缺点

###### 优点

可以动态创建对象，带来很多灵活性

###### 缺点

由于反射是一种解释操作，这类操作慢于直接执行相同的操作，所以对性能有影响

##### 反射相关api:

* java.lang.Class:表示一个类
* java.lang.reflcect.Method: 表示类的方法
* java.lang.reflect.Field: 表示类的成员变量
* java.lang.reflect.Constructor: 表示类构造器

Object类中的getClass()方法返回的是一个Class类，Class类是Java反射的源头，也就是说可以通过对象反射求出类的名称。对象照镜子后可以得到的信息:某个类的成员变量、方法、构造器

想用反射，必须先获得对应的Class对象

##### 如何获取class类的实例

``` bash
# 1.已知具体类，可以通过类的class属性获取,这种方法最安全可靠，程序性能最高
Class clazz = Person.class
```

```bash
# 2. 通过某个对象的getClass()方法获取
Class clazz = person.getClass();
```

```bash
# 3. 通过类的全限定名加载
Class clazz = Class.forName("com.ak.juc.person");
```

```bash
# 如果是内置的基本类型可以使用“基本类型的类名.Type”来获取
Class clazz = Integer.Type;
```

```bash
# 利用ClassLoader
```

