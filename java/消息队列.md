## 消息模型:
* 点对点: 生产者向消息队列中发送一个消息后，只能被一个消费者消费一次
* 发布/订阅: 生产者向频道发送一个消息后，所有订阅了该频道的消费者都可以收到这条消息并消费

### 发布订阅模式和观察者模式有哪些不同？
>1. 观察者模式中,观察者和主题都知道对方的存在;而发布订阅模式中，生产者和消费者互相不知道对方的存在，它们之间通过频道进行通信
>2. 观察者模式是同步的，当事件触发时，主题会调用观察者的方法，然后等待方法返回;而发布订阅模式是异步的，生产者向频道发送一个消息后，不需要关心消费者何时消费这条消息，可以立即返回

## 使用场景:
* 解耦:如果模块之间直接调用，这样耦合度很高，那么修改一个模块或者新增一个模块时对其他模块的影响会很大，没有扩展性。通过使用消息队列，一个模块只需要向消息队列中发送消息，其他模块可以选择性地从消息队列中消费消息从而完成调用
* 异步:同步场景是发送者发送请求后等待消费者处理完成后才能返回，而异步场景中发送者将消息投递到 MQ 中，不需要等待处理完成立即可以返回，然后消费者从 MQ 
中获取并消费消息，以此提高响应速度。只有业务流程允许异步处理的情况下才可以这么做，假如要求实时响应的场景就不能做异步处理(注册流程中如果要求用户对验证邮件进行点击后才能完成注册，就不能使用 MQ )
* 削峰:高并发场景下，短时间内到来的大量请求会压垮服务器。可以将请求发送到 MQ中，服务器按照处理能力从MQ中消费消息
















### 引入 MQ 可能导致的问题:
消息丢失，消息重复，消息积压

### 如何保证发送端的可靠性？也就是说如何确保消息一定投递到 MQ 中？
* 实现方法：利用本地数据库的事务机制，在本地数据库建立一张消息表，将消息数据和业务数据保存在本地数据库中，事务成功提交后，异步将消息表中消息投递到 MQ ，若成功投递则删除消息表中数据，否则重试

### 如何保证接收端的可靠性？也就是说如何确保接收端一定能够从消息队列成功消费一次消息？
>1. 保证消费端处理消息的业务逻辑具有幂等性，这样无论消费多少次消息，最后的处理结果都是一样的
>2. 保证消息具有全局唯一编号，并使用一张日志表来记录已经消费的消息编号

Rabbitmq普通集群模式缺点：
1. 可能会在rabbitmq集群内部产生大量的数据传输
2. 可用性几乎没什么保障

镜像集群模式缺点：每个节点上都有这个queue的，不是分布式的，负载大于一个节点的最大负载就无法解决了

Rabbitmq设置持久化的两个步骤：
1. 创建queue时候将其设置为持久化的，这样可以保证rabbitmq持久化queue的元数据，但是不会持久化queue里面的数据
2. 发送消息的时候将消息的deliveryMode设置为2，就是将消息设置为持久化的，此时rabbitmq就会将消息持久化到磁盘。必须同时设置这两个持久化才行

![avatar](../static/mq1.png)

![avatar](../static/mq2.png)