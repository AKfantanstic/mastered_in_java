## 消息模型:
* 点对点: 生产者向消息队列中发送一个消息后，只能被一个消费者消费一次
* 发布/订阅: 生产者向频道发送一个消息后，所有订阅了该频道的消费者都可以收到这条消息并消费

### 发布订阅模式和观察者模式有哪些不同？
>1. 观察者模式中,观察者和主题都知道对方的存在;而发布订阅模式中，生产者和消费者互相不知道对方的存在，它们之间通过频道进行通信
>2. 观察者模式是同步的，当事件触发时，主题会调用观察者的方法，然后等待方法返回;而发布订阅模式是异步的，生产者向频道发送一个消息后，不需要关心消费者何时消费这条消息，可以立即返回

## 使用场景:
* 解耦:如果模块之间直接调用，这样耦合度很高，那么修改一个模块或者新增一个模块时对其他模块的影响会很大，没有扩展性。通过使用消息队列，一个模块只需要向消息队列中发送消息，其他模块可以选择性地从消息队列中消费消息从而完成调用
* 异步:同步场景是发送者发送请求后等待消费者处理完成后才能返回，而异步场景中发送者将消息投递到 MQ 中，不需要等待处理完成立即可以返回，然后消费者从 MQ 
中获取并消费消息，以此提高响应速度。只有业务流程允许异步处理的情况下才可以这么做，假如要求实时响应的场景就不能做异步处理(注册流程中如果要求用户对验证邮件进行点击后才能完成注册，就不能使用 MQ )
* 削峰:高并发场景下，短时间内到来的大量请求会压垮服务器。可以将请求发送到 MQ中，服务器按照处理能力从MQ中消费消息



### 为什么使用消息队列?消息队列都有哪些使用场景？你项目里具体是什么场景？
* 考点分析:没有对自己的架构问过为什么的人一定是平时没有独立思考的人，要学会独立思考，而不是拿别人的架构就去用

常见的消息队列使用场景有很多，比较核心的有3个场景:解耦、异步、削峰
* 解耦: 耦合场景:A系统和BCD系统通过接口调用的方式通信，假如E系统也需要A系统发送的数据，同时C系统不再需要A系统
发送的数据，这时候只能A系统修改代码，因为A系统和BCDE系统产生了严重耦合。并且A系统需要考虑BCDE系统不可用如何处理
，是重发还是存储消息？这就是耦合带来的问题。
![avatar](../static/耦合.jpg)

使用MQ后解耦处理:引入MQ后，A系统只需要将消息投递到MQ里，不需要考虑BCD系统是否可用，超时等问题，
当引入E系统需要A系统发送的数据时，E系统只需要订阅A系统的消息即可。也就是说，
通过引入MQ的发布订阅模型将A系统和BCD系统彻底解耦
![avatar](../static/解耦.jpg)

项目场景: ？？？？？？

* 异步: 同步场景:用户向A系统发送一个请求，A系统通过接口调用同步调用BCD系统，A系统写数据库耗时3ms,
BCD系统写数据库总耗时为300+450+200=950ms，一般互联网企业对于用户直接的操作要求每个请求必须在200ms以内完成，
对用户几乎无感知，而同步调用操作耗时接近1s，几乎不可接受
![avatar](../static/同步调用场景.jpg)

异步改造后: 引入MQ后，用户向A系统发起请求，A系统向MQ投递3条消息耗时5ms，总时长是3+5=8ms后返回给用户，
体验极好。投递消息后由BCD系统从相应的MQ队列中拉取消息并消费，此过程用户无感知。
![avatar](../static/异步场景.jpg)

项目场景: ？？？？？？

* 削峰: 高峰低谷场景:00:00-12:00时间段内，A系统每秒并发请求量只有50个，到了12:00-13:00时间段内，
每秒并发请求量暴增到5k+条。该系统直接基于MySQL，大量请求打入MySQL，每秒钟需要MySQL执行5k+条SQL，
而mysql每秒可以处理2k个请求，如果每秒请求5k+的话，会直接导致mysql宕机，进而导致系统崩溃。当高峰期一过，
下午是请求低谷，每秒并发请求量又回到50个请求。
![avatar](../static/高峰.jpg)

引入MQ削峰后场景:引入MQ后，每秒5k个请求写入MQ。因为MySQL每秒最多处理2k个请求，所以A系统每秒钟最多处理2k个请求，
A系统从MQ中慢慢拉取消息并消费，只要不超过自己每秒最大请求数量就可以，这样哪怕是在高峰期，A系统也不会挂掉。
而中午高峰期可能会积压几十万甚至上百万的消息在MQ中，但是这个短暂的高峰积压是没关系的，因为到低谷期时，
每秒并发请求数只有50个，而A系统依然会以每秒2k条消息的速度在处理，消费速度大于生产速度，
所以A系统在低谷期会快速将积压的消息消费掉。
![avatar](../static/削峰.jpg)

项目场景: ？？？？？？

### 消息队列有什么优点和缺点？
* 考点分析:引入中间件是一定有好处有坏处的，需要明确引入中间件带来的弊端和风险
优点: 在解耦、异步、削峰等特殊场景下有对应的好处
缺点: 
>1. 系统可用性降低: 系统引入的外部依赖越多，越容易挂掉。因为加入mq后，如果mq挂掉会导致整套系统崩溃，所以需要保证消息队列的高可用，从而来保证整套系统的高可用
>2. 系统复杂性提高:  引入MQ后，需要考虑消息重复、消息丢失、消息顺序性等针对引入mq后带来的问题的解决方案
>3. 一致性问题: A系统写入MQ后直接返回，整个交易需要ABCD全部处理成功才可以，问题是如果BCD三个系统中，BD两个系统写库成功，C系统写库失败，也就是说中间某一环节失败了，如何保证数据的整体一致性。

总结: 消息队列是一种非常复杂的架构，引入它享受它的好处，但是也需要针对它带来的坏处做各种额外的技术方案来应对。可能做好处理后系统复杂度提升了一个数量级，但是关键时刻该用还是得用。

### kafka、ActiveMQ、RabbitMQ、RocketMQ都有什么区别，以及适合哪些场景？
* 考点分析:引入中间件之前一定要做技术选型，要对业界流行的MQ做调研，看用在哪个场景可以扬长避短，用其优势，避其劣势，避免留坑

| 特性 | ActiveMQ | RabbitMQ | RocketMQ | Kafka |
|---|---|---|---|---|
| 单机吞吐量 | 万级，比 RocketMQ、Kafka 低一个数量级 | 万级 | 10 万级，能支撑高吞吐 | 10 万级，能支撑高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景 |
| topic 数量对吞吐量的影响 | | | topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器数目下可以支撑大量的 topic | topic 
从几十到几百个时候，吞吐量会大幅度下降，在同等机器数目下使用Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源 |
| 时效性 | ms 级 | 微秒级，低延迟是 RabbitMQ 的一大特点，延迟最低 | ms 级 |  ms 级 |
| 可用性 | 高，基于主从架构实现高可用 | 高，基于主从架构实现高可用 | 非常高，分布式架构 | 非常高，分布式架构，一个数据多个副本，少数机器宕机不会丢失数据也不会导致不可用 |
| 消息可靠性 | 有较低的概率丢失数据 | 基本不丢 | 经过优化的参数配置，可以做到 0 丢失 | 经过优化的参数配置，可以做到 0 丢失 |
| 功能支持 | MQ 领域的功能极其完备 | 基于 erlang 开发，并发能力很强，性能好延时低 | MQ 功能较为完善，分布式架构扩展性好 | 功能较为简单，主要支持简单的 MQ 
功能，在大数据领域的实时计算以及日志采集被大规模使用 |

* 结论:
>1. 一般公司的业务系统在引入MQ时，最早大家都用ActiveMQ，现在由于社区不活跃，没有经过大规模吞吐量场景的验证，目前不推荐使用。
>2. 后来大家开始使用RabbitMQ，但是erlang语言组织了大量的Java工程师去深入研究和掌控它，对公司而言几乎处于不可控状态。好在社区活跃度高，支持稳定
>3. 目前越来越多的公司选择用RocketMQ，经过阿里大规模场景验证，但是社区有黄掉风险(RocketMQ已捐给Apache，但是Github上活跃度不高)
，如果对自己公司技术实力没有绝对自信，还是推荐用RabbitMQ，RabbitMQ有活跃的开源社区绝对不会黄
>4. 中小型公司，技术实力较为一般，技术挑战不是特别高，用RabbitMQ是不错的选择；大型公司基础架构研发实力较强，用RocketMQ是很好的选择，可以基于RocketMQ进行一些个性化的2次开发
>5. 如果是大数据领域的实时计算、日志采集等场景，用Kafka是业内标准，也几乎是全世界大数据领域的事实性规范，社区活跃度很高，绝对不会黄

### 如何保证消息队列的高可用？
* 考点分析: 问到MQ这块，高可用是必问的，因为引入MQ会导致系统可用性降低，所以肯定围绕MQ的这些缺点问解决办法，
有水平的面试官，问的是MQ的高可用性怎么保证？这样你用过哪个MQ就说说那个MQ的高可用的理解就好了。

* RabbitMQ的高可用性:
RabbitMQ有3种模式: 单机模式、普通集群模式、镜像集群模式
>1. 单机模式: demo级别，一般不应用于生产
>2. 普通集群模式(无高可用性): 多台物理机上启动多个实例，每个实例都同步Queue的元数据，但是创建的Queue只会在一个实例上存放实际数据。消费时
如果连接了另一个实例，那么这个实例会从实际存放数据的Queue所在实例上拉取数据。此方案主要是通过让集群中的多个节点来服务
某个Queue的读写来提高吞吐量，不保证高可用性。
缺点:
1. 没做到分布式，就是个普通集群。若消费者固定连接Queue所在实例来消费，会导致单实例性能瓶颈；
若消费者每次随机连接一个实例然后拉取数据后消费，会有数据拉取开销。
2. 可用性没有保障，开启消息持久化后消息不会丢失，但是当存放实际数据的queue实例宕机会导致其他实例无法从那个实例拉取数据消费
![avatar](../static/RabbitMQ普通集群模式.jpg)
>3. 镜像集群模式(高可用性): 这种模式能保证RabbitMQ的高可用性。镜像集群模式下创建的Queue，无论元数据还是Queue中实际
存储的数据都会存在于多个实例上，也就是说每个RabbitMQ实例上都有每个Queue的完整镜像，每次向队列写入消息时，都会自动把消息
同步到多个实例的Queue上。
![avatar](../static/RabbitMQ镜像集群模式.jpg)
优点:任何一台机器宕机，不影响系统，保证了高可用性
缺点:
1. 消息需要同步到所有机器上，网络带宽压力等性能开销大。
2. 不是分布式架构导致没有扩展性，整个集群的最大负载量瓶颈就是单个实例的负载量。高负载下无法线性扩展，也就是加机器无法解决性能瓶颈问题

* kafka的高可用性:

![avatar](../static/kafka-0.8.jpg)













### 引入 MQ 可能导致的问题:
消息丢失，消息重复，消息积压

### 如何保证发送端的可靠性？也就是说如何确保消息一定投递到 MQ 中？
* 实现方法：利用本地数据库的事务机制，在本地数据库建立一张消息表，将消息数据和业务数据保存在本地数据库中，事务成功提交后，异步将消息表中消息投递到 MQ ，若成功投递则删除消息表中数据，否则重试

### 如何保证接收端的可靠性？也就是说如何确保接收端一定能够从消息队列成功消费一次消息？
>1. 保证消费端处理消息的业务逻辑具有幂等性，这样无论消费多少次消息，最后的处理结果都是一样的
>2. 保证消息具有全局唯一编号，并使用一张日志表来记录已经消费的消息编号

Rabbitmq普通集群模式缺点：
1. 可能会在rabbitmq集群内部产生大量的数据传输
2. 可用性几乎没什么保障

镜像集群模式缺点：每个节点上都有这个queue的，不是分布式的，负载大于一个节点的最大负载就无法解决了

Rabbitmq设置持久化的两个步骤：
1. 创建queue时候将其设置为持久化的，这样可以保证rabbitmq持久化queue的元数据，但是不会持久化queue里面的数据
2. 发送消息的时候将消息的deliveryMode设置为2，就是将消息设置为持久化的，此时rabbitmq就会将消息持久化到磁盘。必须同时设置这两个持久化才行

![avatar](../static/mq1.png)

![avatar](../static/mq2.png)