## 消息模型:
* 点对点: 生产者向消息队列中发送一个消息后，只能被一个消费者消费一次
* 发布/订阅: 生产者向频道发送一个消息后，所有订阅了该频道的消费者都可以收到这条消息并消费

### 发布订阅模式和观察者模式有哪些不同？
>1. 观察者模式中,观察者和主题都知道对方的存在;而发布订阅模式中，生产者和消费者互相不知道对方的存在，它们之间通过频道进行通信
>2. 观察者模式是同步的，当事件触发时，主题会调用观察者的方法，然后等待方法返回;而发布订阅模式是异步的，生产者向频道发送一个消息后，不需要关心消费者何时消费这条消息，可以立即返回

## 使用场景:
* 解耦:如果模块之间直接调用，这样耦合度很高，那么修改一个模块或者新增一个模块时对其他模块的影响会很大，没有扩展性。通过使用消息队列，一个模块只需要向消息队列中发送消息，其他模块可以选择性地从消息队列中消费消息从而完成调用
* 异步:同步场景是发送者发送请求后等待消费者处理完成后才能返回，而异步场景中发送者将消息投递到 MQ 中，不需要等待处理完成立即可以返回，然后消费者从 MQ 
中获取并消费消息，以此提高响应速度。只有业务流程允许异步处理的情况下才可以这么做，假如要求实时响应的场景就不能做异步处理(注册流程中如果要求用户对验证邮件进行点击后才能完成注册，就不能使用 MQ )
* 削峰:高并发场景下，短时间内到来的大量请求会压垮服务器。可以将请求发送到 MQ中，服务器按照处理能力从MQ中消费消息



### 为什么使用消息队列?消息队列都有哪些使用场景？你项目里具体是什么场景？
* 考点分析:没有对自己的架构问过为什么的人一定是平时没有独立思考的人，要学会独立思考，而不是拿别人的架构就去用

常见的消息队列使用场景有很多，比较核心的有3个场景:解耦、异步、削峰
* 解耦: 耦合场景:A系统和BCD系统通过接口调用的方式通信，假如E系统也需要A系统发送的数据，同时C系统不再需要A系统
发送的数据，这时候只能A系统修改代码，因为A系统和BCDE系统产生了严重耦合。并且A系统需要考虑BCDE系统不可用如何处理
，是重发还是存储消息？这就是耦合带来的问题。
![avatar](../static/耦合.jpg)

使用MQ后解耦处理:引入MQ后，A系统只需要将消息投递到MQ里，不需要考虑BCD系统是否可用，超时等问题，
当引入E系统需要A系统发送的数据时，E系统只需要订阅A系统的消息即可。也就是说，
通过引入MQ的发布订阅模型将A系统和BCD系统彻底解耦
![avatar](../static/解耦.jpg)

项目场景: ？？？？？？

* 异步: 同步场景:用户向A系统发送一个请求，A系统通过接口调用同步调用BCD系统，A系统写数据库耗时3ms,
BCD系统写数据库总耗时为300+450+200=950ms，一般互联网企业对于用户直接的操作要求每个请求必须在200ms以内完成，
对用户几乎无感知，而同步调用操作耗时接近1s，几乎不可接受
![avatar](../static/同步调用场景.jpg)

异步改造后: 引入MQ后，用户向A系统发起请求，A系统向MQ投递3条消息耗时5ms，总时长是3+5=8ms后返回给用户，
体验极好。投递消息后由BCD系统从相应的MQ队列中拉取消息并消费，此过程用户无感知。
![avatar](../static/异步场景.jpg)

* 削峰: 高峰低谷场景:00:00-12:00时间段内，A系统每秒并发请求量只有50个，到了12:00-13:00时间段内，
每秒并发请求量暴增到5k+条。该系统直接基于MySQL，大量请求打入MySQL，每秒钟需要MySQL执行5k+条SQL，
而mysql每秒可以处理2k个请求，如果每秒请求5k+的话，会直接导致mysql宕机，进而导致系统崩溃。当高峰期一过，
下午是请求低谷，每秒并发请求量又回到50个请求。
![avatar](../static/高峰.jpg)

引入MQ削峰后场景:引入MQ后，每秒5k个请求写入MQ。因为MySQL每秒最多处理2k个请求，所以A系统每秒钟最多处理2k个请求，
A系统从MQ中慢慢拉取消息并消费，只要不超过自己每秒最大请求数量就可以，这样哪怕是在高峰期，A系统也不会挂掉。
而中午高峰期可能会积压几十万甚至上百万的消息在MQ中，但是这个短暂的高峰积压是没关系的，因为到低谷期时，
每秒并发请求数只有50个，而A系统依然会以每秒2k条消息的速度在处理，消费速度大于生产速度，
所以A系统在低谷期会快速将积压的消息消费掉。
![avatar](../static/削峰.jpg)



      
      



### 消息队列有什么优点和缺点？
考点分析:引入中间件是一定有好处有坏处的，需要明确引入中间件带来的弊端和风险

### kafka、ActiveMQ、RabbitMQ、RocketMQ都有什么区别，以及适合哪些场景？
考点分析:引入中间件之前一定要做技术选型，要对业界流行的MQ做调研，看用在哪个场景可以扬长避短，用其优势，避其劣势，避免留坑












### 引入 MQ 可能导致的问题:
消息丢失，消息重复，消息积压

### 如何保证发送端的可靠性？也就是说如何确保消息一定投递到 MQ 中？
* 实现方法：利用本地数据库的事务机制，在本地数据库建立一张消息表，将消息数据和业务数据保存在本地数据库中，事务成功提交后，异步将消息表中消息投递到 MQ ，若成功投递则删除消息表中数据，否则重试

### 如何保证接收端的可靠性？也就是说如何确保接收端一定能够从消息队列成功消费一次消息？
>1. 保证消费端处理消息的业务逻辑具有幂等性，这样无论消费多少次消息，最后的处理结果都是一样的
>2. 保证消息具有全局唯一编号，并使用一张日志表来记录已经消费的消息编号

Rabbitmq普通集群模式缺点：
1. 可能会在rabbitmq集群内部产生大量的数据传输
2. 可用性几乎没什么保障

镜像集群模式缺点：每个节点上都有这个queue的，不是分布式的，负载大于一个节点的最大负载就无法解决了

Rabbitmq设置持久化的两个步骤：
1. 创建queue时候将其设置为持久化的，这样可以保证rabbitmq持久化queue的元数据，但是不会持久化queue里面的数据
2. 发送消息的时候将消息的deliveryMode设置为2，就是将消息设置为持久化的，此时rabbitmq就会将消息持久化到磁盘。必须同时设置这两个持久化才行

![avatar](../static/mq1.png)

![avatar](../static/mq2.png)