### 1.知识没体系，转身就忘记  ---《MySQL实战45讲》
* 把知识点“写下来”，还有一个好处，就是你会发现这个知识点的关联知识点。深究下去，点就连成线，然后再跟别的线交叉。
把这些都搞明白以后，你就能够把临时表、日志格式、同步机制，甚至于事务机制都连起来了。
* 相信你和我一样，在学习过程中最喜欢的就是这种交叉的瞬间。交叉多了，就形成了网络。
而有了网络以后，吸收新知识的速度就很快了。
* 比如，如果你对事务隔离级别弄得很清楚了，在看到第 45 篇文章讲的 max_trx_id 超限会导致持续脏读的时候，
相信你理解起来就很容易了。

### 2.看过的知识必须整理成自己的话术与语言,整理成笔记，才算是真的看懂了

### 3.mysql 的redolog 和binlog 机制在很多框架中都有相似的影子。2段提交、分布式事务等等

### 4.重点看些开发需要用到的，比如：锁、索引、事务、主从同步,explain分析执行过程。也尽可能的根据自己的理解和实践来总结这些知识点。

### 5.不同语言运行过程的比较:
* 编译型语言：C/C++、 Pascal（Delphi）
编译就是把源代码（高级语言，人类容易读，容易理解）转换成机器码（CPU能理解，能高效的执行）
* 解释型语言：JavaScript、Perl、Python、Ruby
解释就简单多了，解析源代码，并且直接执行，没有编译过程
* 编译程序是整体编译完了，再一次性执行。 而解释程序是一边解释，一边执行
* 而 Java 语言是一种先编译-后解释型语言，同时具备编译特性和解释特性
,其所谓的编译过程只是将.java文件编译成平台无关的字节码.class文件，
这步并不是像 C 一样编译成可执行的机器码，这里注意Java中所谓的“编译”和传统的“编译”的区别。
* 比如我们大多数情况使用的Hotspot JVM，提供了动态即时编译器JIT，能够追踪热点代码， 然后直接编译成成机器码，这种情况下部分热点代码就属于编译执行，而不是解释执行了  

### 6.线程会共享进程范围内的资源，比如内存句柄和文件句柄。但每个线程都有各自的程序计数器，栈以及局部变量。

### 7.操作系统调度的调度单位为线程，所以如果程序中只有一个线程，那么最多同时只能在一个核心上运行。
在双核处理器上，单线程程序只能使用一个核心，在100核处理器上，将有99个核心空闲。

### 8.Java.concurrent.util包中的原子类适用于全局竞争的变量，也就是会被多个线程同时访问到的变量，如果修改这样的变量，就需要用原子类。

### 竞态条件判断：也就是在进行判断时，值会被其他线程更改，导致判断的结果可能是错误的

要保持状态的一致性，需要在单个原子操作中更新所有相关的状态变量。
只把其中一个状态变量声明为原子的是不行的，必须用单个原子操作中更新所有相关的状态变量。

为什么在访问某个共享且可变的变量时要求所有线程在同一个锁上同步，(因为Java线程之间的通信基于共享内存，而不是通过消息传递)
因为要确保某个线程写入该变量的指对于其他线程来说都是可见的。

加锁的含义不仅仅局限于互斥行为，还包括内存可见性，为了确保所有线程都能看到共享变量的最新值，
所有执行读操作或者写操作的线程都必须在同一个锁上同步

加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。

什么时候该使用volatile变量？
1. 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值
2. 该变量不会与其他状态变量一起纳入不变性条件中
3. 在访问变量时不需要加锁。

### 画家学习绘画的方法主要是动手去画，黑客学习编程的方法也理应如此

### 大脑是需要用后台线程来处理神经之间的联结的，所以因为专注模式会占满所有大脑cpu资源，而后台线程的运行也是需要cpu资源的，所以需要从专注模式转换到发散模式，让出cpu资源，让后台线程得到执行。

### 就我所知，当多个画家共同创作一幅作品时，每个人画的部分都是不一样的。
通常来说，大师负责画主要人物，助手们负责画次要人物和背景。但是，你肯定找不到某个部分是两个人一起画的。我认为，这也是多人共同开发一个软件的正确模式。
需要合作，但是不要“合”得过头。如果一个代码块由三四个人共同开发，就没有人真正“拥有”这块代码。
最终，它就会变得像一个公用杂物间，没人管理，又脏又乱，到处堆满了冗余代码。
正确的合作方法是将项目分割成严格定义的模块，每一个模块由一个人明确负责。模块与模块之间的接口经过精心设计，
如果可能的话，最好把文档说明写得像编程语言规范那样清晰。

### 实战经验大于自学经验
* 面试的一大重点就是项目中所用到的技术点，最好是实际项目中用过的，自学的和经过项目实践的是属于两个层次。
请记得，“实践经验”一定比“理论经验”值钱，而且大多数你知道的理论上的经验，一定在你的项目里用过。所以，
如果你仅仅让面试官感觉你只有“理论经验”，那就太亏了。面试官更倾向于相信你实际在项目中用到的技术点。

### 为什么困难的知识学不会？
没有特别难的知识，只是构成这个知识的基础你不会而已。找到那些基础。学会它自然就会了这个所谓很难的知识

### 摘抄自-公众号
JDK1.8 中 ArrayList 的源码有1400多行（注释估计占了一半），但是我们不需要全部看，我们只需要看其中重要的内容：基础属性、构造方法、get 方法、set 方法、add 方法、remove 方法、扩容方法等。
看完 ArrayList 之后再继续看它的老婆类 LinkedList，面试中这2个类一般会被拿来一起问。看完这两个类的源码后，再结合源码看看面试中会问的题目，这个知识点基本就掌握的差不多了。 
,这时候建议可以开始看复杂一点的，优先推荐 HashMap，HashMap 是现在面试中被问的最多的基础知识点应该没有之一，HashMap 的源码比 ArrayList 复杂的不是一点半点，再加上 JDK 那写的贼不规范的源码，看着就脑壳疼。
我看过的书中，在这个阶段，我个人推荐的是：《Java 并发编程的艺术》、《Java 并发编程实战》、《深入理解 Java 虚拟机》（最近出了第三版）、《Redis设计与实现》。当时的我还是个小菜鸡，但是读这几本书，并不会觉得有读不下去的感觉，因此我觉得适合在这个阶段去读。

### 想要在学习中触类旁通，前提就是知识面有广度 ---《网络是怎样连接的》

### 人习惯的是流程化思维，通过流程将知识点串起来不容易忘。 ---自己面试感悟

### ---CyC2018
很多人都说，面试和考试一样，要背很多没用的东西。最开始我也认同这种看法，可是参加了几场面试之后，我就不这么认为了。因为面试出的问题，有很多是实际开发中碰到的，所以准备面试相当于提前做入职准备。而且面试中考察的思维能力、交流表达能力、应对压力能力，都是真正工作中所需要的。
我觉得自己比别人做的好的地方是，有很强烈的想找到好工作的意愿，才驱使我不断学习，所以态度很重要。
信心源自于充分准备，有了信心，面试的时候才能游刃有余。而毫无依据的自我感觉良好，在每次失败之后都看不到自身的不足，而是怪罪于外界因素。

### 广度优先的意义
多去理解框架，或者jdk作者，或者是在历史发展过程中的其他技术，为什么最后是这样决定的，这样的发展走向，多去理解而不是死记硬背，要有同理心， 
能站在作者设计的角度去思考问题，而不是死记硬背。很多时候现有的流行技术是留下来的最佳实践而已，中间缺少了一些发展的历史背景。比如说自旋锁的出现， 
是有一定的应用场景的，怎么个自旋思想，什么情况下自旋有效？什么情况下自旋失效？都是有一整套历史背景的。在那个遥远的时代，redis只有单机模式，
后面有人发现挂了，会丢数据，所以，他自己又搞了另一台机器作为备库，平时写数据的时候往备库同步一份，自己检测到主库挂了，切换到备库。后来，
人们发现自己去检测太麻烦了，还要同步数据，所以，搞出来个哨兵，哨兵帮你去干这个事，还不用跟业务代码耦合，所以哨兵本质上也是主从模式。
在主从模式下，每台机器都是全量的数据，主要对抗网络风险。随着业务量的不断增加，发现一台机器存不下那么多数据了，此时，也有很多办法，比如，
按业务分成不同的Redis主从，相当于手动分片，这样不方便管理，而且一个系统连多个redis复杂性也很高，在大家的呼声中，redis官方索性搞出个集群，
将数据分片，降低单机数据量，同时增加从节点对抗网络风险。在以前大家都用redis锁，很爽，出了集群还要不要用redis锁呢？redis作者肯定是支持的，
但是有人反对，太慢了，这就引出了redis作者与那谁的撕逼大战










