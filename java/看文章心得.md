### 1.知识没体系，转身就忘记 from《MySQL实战45讲》
* 把知识点“写下来”，还有一个好处，就是你会发现这个知识点的关联知识点。深究下去，点就连成线，然后再跟别的线找交叉。
把这些都搞明白以后，你就能够把临时表、日志格式、同步机制，甚至于事务机制都连起来了。
* 相信你和我一样，在学习过程中最喜欢的就是这种交叉的瞬间。交叉多了，就形成了网络。
而有了网络以后，吸收新知识的速度就很快了。
* 比如，如果你对事务隔离级别弄得很清楚了，在看到第 45 篇文章讲的 max_trx_id 超限会导致持续脏读的时候，
相信你理解起来就很容易了。


### 2.看过的知识必须整理成自己的话术与语言,整理成笔记，才算是真的看懂了

### 3.mysql 的redolog 和binlog 机制在很多框架中都有相似的影子。2段提交、分布式事务等等

### 4.重点看些开发需要用到的，比如：锁、索引、事务、主从同步,explain分析执行过程。也尽可能的根据自己的理解和实践来总结这些知识点。

### 5.不同语言运行过程的比较:
* 编译型语言：C/C++、 Pascal（Delphi）
编译就是把源代码（高级语言，人类容易读，容易理解）转换成机器码（CPU能理解，能高效的执行）
* 解释型语言：JavaScript、Perl、Python、Ruby
解释就简单多了，解析源代码，并且直接执行，没有编译过程
* 编译程序是整体编译完了，再一次性执行。 而解释程序是一边解释，一边执行
* 而 Java 语言是一种先编译-后解释型语言，同时具备编译特性和解释特性
,其所谓的编译过程只是将.java文件编译成平台无关的字节码.class文件，
这步并不是像 C 一样编译成可执行的机器码，这里注意Java中所谓的“编译”和传统的“编译”的区别。
* 比如我们大多数情况使用的Hotspot JVM，提供了动态即时编译器JIT，能够追踪热点代码， 然后直接编译成成机器码，这种情况下部分热点代码就属于编译执行，而不是解释执行了  

### 6.线程会共享进程范围内的资源，比如内存句柄和文件句柄。但每个线程都有各自的程序计数器，栈以及局部变量。

### 7.操作系统调度的调度单位为线程，所以如果程序中只有一个线程，那么最多同时只能在一个核心上运行。
在双核处理器上，单线程程序只能使用一个核心，在100核处理器上，将有99个核心空闲。

### 8.Java.concurrent.util包中的原子类适用于全局竞争的变量，也就是会被多个线程同时访问到的变量，
如果修改这样的变量，就需要用原子类。
AtomicReference

### 竞态条件判断：也就是在进行判断时，值会被其他线程更改，导致判断的结果可能是错误的


要保持状态的一致性，需要在单个原子操作中更新所有相关的状态变量。
只把其中一个状态变量声明为原子的是不行的，必须用单个原子操作中更新所有相关的状态变量。

为什么在访问某个共享且可变的变量时要求所有线程在同一个锁上同步，(因为线程之间的沟通基于共享内存，而不是通过消息，)
因为要确保某个线程写入该变量的指对于其他线程来说都是可见的。

加锁的含义不仅仅局限于互斥行为，还包括内存可见性，为了确保所有线程都能看到共享变量的最新值，
所有执行读操作或者写操作的线程都必须在同一个锁上同步



