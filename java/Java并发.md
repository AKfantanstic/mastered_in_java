### 1. ThreadLocal 线程本地变量:



对threadLocal的理解可以分为3个方面:
1.应用场景: 首先只适用于多线程场景，   框架应用场景：Spring的事务管理，用ThreadLocal存储Connection，从而各个DAO可以获取同一Connection，可以进行事务回滚，提交等操作。
 2.内部细节 3. 最佳实践
是个啥，字面翻译过来，这是个线程本地变量。首先它是个类，可以被实例化为对象，这对象就3个方法，get，set，remove

### 2. 并发与并行有什么区别？
个人理解，并发是一种竞争关系，并行是一种合作关系。一堆砖由两个人搬，把一堆砖如何分为两部分，然后让每个人各搬一部分，
这是并行。而并发考虑的是两个人一起搬这堆砖，需要解决的是保证两个人不能同时从这堆砖中拿出一块搬走。  

并发、JVM、分布式、TCP/IP协议这些个关键字
主语言本身以及它的高级特性，第二个阶段是讲述自己的项目，并在中间穿插着问题。
一个线程就是在进程中的一个单一的顺序控制流
如果希望任务完成后有一个返回值，那么需要实现callable接口，callable<String>,返回值类型为Future<String>，
必须使用ExecutorService.submit()方法调用它。因为异常不能跨线程传播，所以必须在本地(run方法中)处理所有在任务内部产生的异常
可以把单线程程序(单线程)看作问题域求解的单一实体，每次只能做一件事，也可以看作是一个盒子，
每次只能装一个东西，装了这个就不能装那个了，也可以看作一根线程，不准确，因为线程是一个容器，
一个盛放任务的容器。也可以是一个停车场，每次只能停一辆车
会被并发访问的资源，需要考虑要不要加锁，将这个资源保护起来。
防止由并发访问造成的错误的方法就是当资源被第一个访问的任务访问时，必须锁定这项资源，
使其他任务在这项资源被解锁之前，无法访问到这项资源。
基本上所有的并发模式在解决线程冲突问题的时候，都是采用序列化访问共享资源的方案。
这意味着在给定时刻只允许一个任务访问共享资源。通常这是通过在代码前面加上一条锁语句来实现的，
这就使得在一段时间内只有一个任务可以运行这段代码。因为锁语句产生了一种互相排斥的效果。
相当于多人洗浴占用浴室场景：多个人(即多个由线程驱动的任务)都希望能单独使用浴室(即使用共享资源)。
为了使用浴室，一个人先敲门，看看能否使用。如果没人的话，他就进入浴室并锁上门。这时其他人要使用浴室，
就会被“阻挡”，所以他们要在浴室门口等待，直到浴室可以使用。当浴室使用完毕，就该把浴室给其他人使用了(其他任务就可以访问资源了)。
在使用synchronized进行同步时，在使用并发时，将域设置为private是非常重要的，否则，synchronized关键字
就不能防止其他任务直接访问域，这样就会产生冲突。意思就是把所有的域都设置为private，然后提供getter，setter方法来修改，
如果用对象.filed来修改filed，这种方式的修改，synchronized是无法保证同步的。

什么时候需要用同步呢？brian同步原则：
如果你正在写一个变量，它可能接下来被另一个线程读取，或者正在读取一个上一次已经被另一个线程写过的变量，
那么你必须使用同步，并且，读写线程都必须用synchronized同步。

### 3.Java 并发类库提供的线程池有哪几种？ 分别有什么特点？
开发者都是利用 Executors 提供的通用线程池创建方法，去创建不同配置的线程池，
主要区别在于不同的 ExecutorService 类型或者不同的初始参数。
  
Executors 目前提供了 5 种不同的线程池创建配置：  
* newCachedThreadPool()，它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，
当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，
这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列。

* newFixedThreadPool(int nThreads)，重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，
任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，
将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads。

* newSingleThreadExecutor()，它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，
所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，
因此可以避免其改变线程数目。

* newSingleThreadScheduledExecutor() 和 newScheduledThreadPool(int corePoolSize)，
创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程。

* newWorkStealingPool(int parallelism)，这是一个经常被人忽略的线程池，Java 8 
才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序。



## 线程池的用处:并行执行任务，异步处理
使用线程池的好处：
当提交一个新任务到线程池时，线程池是怎样处理的？(ThreadPoolExecutor执行execute方法的内部处理流程)
(1)线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。
如果核心线程池里的线程都在执行任务，则进入下一个流程
(2)线程池判断工作队列(workQueue)是否已经满了。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。
如果工作队列满了，则进入下个流程。
(3)线程池判断线程池的线程是否都处在工作状态。如果没有，则创建一个新的工作线程来执行任务。如果满了，则交给饱和策略来处理这个任务。
线程池的实现原理：线程池创建线程时，会将线程封装成工作线程worker，worker在执行完任务后，还会循环获取工作队列里的任务来执行。
jdk自带的几种饱和策略？
AbortPolicy 直接抛出异常，这是默认策略
DiscardPolicy，不处理直接丢弃掉
CallRunsPolicy，只用调用者所在线程来运行任务
DiscardOldestPolicy 丢掉队列里最近的一个任务，并执行当前任务
使用ThreadPoolExecutor创建线程池的几个参数？
corePoolSize(核心线程池的大小):
maximumPoolSize(线程池最大线程数量):线程池允许创建的最大线程数，注意：如果使用了无界的工作队列这个参数就没效果了
keepAliveTime:工作线程空闲后，允许存活的时间
ThreadFactory:用于设置创建线程的工厂，主要目的是通过工厂创建的线程可以设置更有意义的名字(可以用guava提供的ThreadFactoryBuilder为线程池里的线程快速设置有意义的名字)

调用线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。

### 如何向线程池提交任务？
execute()方法:用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功
submit()方法:用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过future对象可以判断任务是否执行成功。
调用future.get()方法可以获取返回值。get()方法会阻塞当前线程直到任务完成，
而get(long timeout,TimeUnit unit)会阻塞当前线程一段时间后，立即返回，这时任务有可能还没执行完，所以可能future对象携带的返回值可能是空对象

###如何关闭线程池？关闭线程池的原理是什么？
调用线程池的shutdown()或shutdownNow方法
原理：遍历线程池中的工作线程，逐个调用线程的interrupt方法来中断线程。所以无法响应中断的任务可能永远无法终止。
区别：shutdownNow先将线程池状态设置为STOP，然后尝试停止所有正在执行或暂停任务的线程。返回等待执行的任务列表(List<Runnable>)
shutdown将线程池状态设置为shutdown，然后中断所有空闲的线程
shutdown方法和shutdownNow如何选择？
一般通过调用shutdown方法来关闭线程池。如果任务不一定要执行完，则可以调用shutdownNow方法

### 说下线程池的生命周期？
running:能接受新提交的任务， 并且也能处理阻塞队列中的任务
shutdown:关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务
stop:不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。
tidying：所有的任务都已终止了，workerCount(有效线程数)为0
terminated：在terminated()方法执行完后进入该状态

描述下线程池的生命周期转换？

建议使用有界队列。

### 系统中大量使用线程池，需要对线程池进行监控，出现问题时，可以根据线程池的使用状况快速定位问题
可以使用线程池提供的参数进行监控:
taskCount:线程池需要执行的任务数量
completeTaskCount:已经完成的任务数量(小于等于taskCount)
largestPoolSize:线程池里曾经创建过的最大线程数量(可以通过该参数知道线程池是否满过，如果该数值等于线程池的最大大小，则表示线程池曾经满过)
getPoolSize:线程池中当前线程数量。(如果线程池不销毁的话，线程池里的线程不会自动销毁，所以这个大小只增不减)
getActiveCount:获取当前活动的线程数

## Java中的锁
锁是用来控制多个线程访问共享资源的方式的，一般来说，一个锁能够防止多个线程同时访问共享资源(但是有些锁可以允许多个线程并发的访问共享资源，比如读写锁)。

### 原子类
