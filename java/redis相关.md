
##### 缓存淘汰策略:
1. FIFO(first in first out) 先进先出策略。使得最先进入的数据被淘汰掉
应用场景: 在实时性比较高的要求下，需要经常访问最新的数据  
2. LRU(Least Recently Used) 最近最久未使用策略。优先淘汰最久未使用的数据  
应用场景:需要保存内存中的数据都是热点数据，保证缓存命中率  
3. LFU(Least Frequently Used) 最不经常使用策略。淘汰一段时间内使用次数最少的数据  

LRU和LFU的区别:  
LRU是淘汰最长时间未被使用的数据，LFU是淘汰一定时间内被访问次数最少的数据  

##### 引入缓存带来的问题:
1. 缓存穿透:用户对某些一定不在缓存中的数据进行请求，则这些请求会直接到达数据库，造成缓存穿透
解决方案:(1)对这类请求进行过滤 (2)对这些不存在的数据缓存一个空数据  

2. 缓存雪崩:指的是缓存数据大面积失效，叫雪崩  
原因:  
(1)数据没有被加载到缓存中  
(2) 缓存在同一时间大量失效  
(3)缓存服务器宕机  
在有缓存起作用的系统中，缓存分担了很大一部分请求，当雪崩发生后，所有请求直接打到数据库，会导致数据库崩溃  
解决方案:  
(1)合理设置缓存过期时间，最好是随机数，这样避免同一时间大面积失效  
(2) 为防止单点故障，可以使用分布式缓存，保证可用性  
(3) 进行缓存预热，避免系统刚启动不久还未将大量数据缓存导致的缓存雪崩  

3. 缓存一致性:在数据更新时缓存必须同时被更新  
解决方案:  
(1) 在更新数据时更新缓存  
(2) 读缓存之前先判断是否为最新缓存，如果不是最新的则更新  

保证缓存一致性需要付出很大代价，所以缓存中最好放点对一致性要求不高的东西。  

##### 正向代理和反向代理:
总结起来就是正向代理隐藏真实客户端，反向代理隐藏真实服务端  

正向代理，代理的是客户端,典型应用是 科学上网。客户端无法上google，客户端请求代理客户端，代理客户端请求google，然后将数据返回给代理客户端，
代理客户端将数据返回给客户端.  

反向代理, 代理的是服务端，也就是假装是原始服务器。代理服务端代理的是真实的服务端，用户发起请求到代理服务端，代理服务端去请求真实服务端，真实服务端
将数据返回给代理服务端，代理服务端将数据返回给用户，看起来就像代理服务端直接给用户返回的数据一样，用户是无感知的，这样可以保护真实的服务端不被攻击。  

反向代理这名字贼烂，叫服务端代理多好，字面意思。控制反转(ioc-inversion-of-control)，听着很蒙B吧，martin flower大师给改个名叫依赖注入(DI,dependency_inject)，好理解多了。








