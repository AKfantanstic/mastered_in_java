##### 单例模式

#### 1. 饿汉式:非常饥饿，直接创建对象
```java
public class Hungry {

    // 直接初始化可能会浪费空间
    private byte[] arr1 = new byte[1024 * 1024];
    private byte[] arr2 = new byte[1024 * 1024];
    private byte[] arr3 = new byte[1024 * 1024];
    private byte[] arr4 = new byte[1024 * 1024];

    // 私有化构造器，防止被外部创建实例
    private Hungry() {}

    private static final Hungry hungry = new Hungry();

    public static Hungry getInstance() {
        return hungry;
    }
}
```

#### 2. 懒汉式:使用双重检查锁的方式实现
```java
/**
 * 用volatile禁止指令重排的原因:
 * java中新建对象不是一个原子操作，而是分为三步:
 * (1)分配内存空间
 * (2)执行类构造方法，初始化对象
 * (3)把对象引用指向内存空间
 * 而在某些编译器中(2)和(3)是可以重排序的，如果发生了重排序，当线程A执行到new lazy()来创建对象时，按(1)(3)(2)的顺序
 * 执行，当执行完(1)(3)时，线程B执行getInstant()方法时会判断lazy引用不是空的，然后直接返回lazy，这时的lazy还没有被
 * 初始化，导致返回null。用volatile禁止new Lazy()的指令重排序
 */
public class Lazy {
    private static volatile Lazy lazy = null;

    private Lazy() {
    }

    public static Lazy getInstant() {
        if (lazy == null) {
            synchronized (Lazy.class) {
                if (lazy == null) {
                    // java中新建对象不是一个原子操作
                    lazy = new Lazy();
                    return lazy;
                }
            }
        }
        return lazy;
    }
}
```

#### 3. 静态内部类:利用JVM的类加载机制特性来保证全局单例
```java
public class Holder {
    // 私有化构造器
    private Holder() {
    }

    public static Holder getInstance() {
        return InnerClass.holder;
    }

    // 静态内部类
    private static class InnerClass {
        private static final Holder holder = new Holder();
    }
}
```
#### 4. 枚举:
```java
public class UcUser {
    // 私有化构造器
    private UcUser() {
    }

    enum SingleTonEnum {
        // 创建一个枚举对象，该对象天生为单例
        Instant;
        private UcUser ucUser;

        SingleTonEnum() {
            ucUser = new UcUser();
        }

        public UcUser getInstant() {
            return ucUser;
        }
    }

    // 对外暴露一个获取user的方法
    public static UcUser getInstance() {
        return SingleTonEnum.Instant.getInstant();
    }

    public static void main(String[] args) {
        System.out.println(UcUser.getInstance().equals(UcUser.getInstance()));
        // 运行结果: true
    }
}
```