### 线程池(重点)

3大方法、7大参数、4种拒绝策略

#### 3大方法:线程池工具类提供的3个创建线程池的方法
数组相关的工具类为Arrays，集合类的工具类为Collections，线程池的工具类为Executors
```java
public class ExecutorsDemo {
    public static void main(String[] args) {
        // 单一线程
        ExecutorService threadPool = Executors.newSingleThreadExecutor();
        // 固定线程数
        ExecutorService threadPool = Executors.newFixedThreadPool(5);
        // 遇强则强，遇弱则弱，可伸缩(可以无限创建线程)
        ExecutorService threadPool = Executors.newCachedThreadPool();
        try {
            for (int i = 1; i <= 10; i++) {
                threadPool.execute(() -> {
                    System.out.println(Thread.currentThread().getName());
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            // 线程池用完程序结束时，关闭线程池
            threadPool.shutdown();
        }
    }
}
```
运行结果:
```
pool-1-thread-1
pool-1-thread-2
pool-1-thread-4
pool-1-thread-5
pool-1-thread-3
pool-1-thread-6
pool-1-thread-7
pool-1-thread-8
pool-1-thread-9
pool-1-thread-10
```
#### 3个方法的本质(源码分析):都是使用ThreadPoolExecutor对象创建线程池
```java
public class Executors {
    
    public static ExecutorService newSingleThreadExecutor() {
        return new Executors.FinalizableDelegatedExecutorService
                (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>()));
    }

    public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                0L, TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue<Runnable>());
    }

    public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                60L, TimeUnit.SECONDS,
                new SynchronousQueue<Runnable>());
    }
}
```
阿里巴巴开发--线程池规约:
![avatar](../../static/阿里线程池规约.png)
##### 7大参数:ThreadPoolExecutor的构造方法需要的7个参数
```java
public class ThreadPoolExecutor {
        public ThreadPoolExecutor(int corePoolSize, // 核心线程数
                                  int maximumPoolSize, // 最大线程数
                                  long keepAliveTime, // 超时没被使用则被回收
                                  TimeUnit unit,     // 超时单位
                                  BlockingQueue<Runnable> workQueue, // 阻塞队列
                                  ThreadFactory threadFactory, // 线程工厂，创建线程的
                                  RejectedExecutionHandler handler) // 拒绝策略 
        {}
}
```

```java
public class ExecutorServiceDemo {
    public static void main(String[] args) {
        ExecutorService threadPool = new ThreadPoolExecutor(3, 5, 3, TimeUnit.SECONDS, new LinkedBlockingQueue<>(3),
                Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy());
        for (int i = 1; i <= 9; i++) {
            // 最大承载 = 最大线程数 + 队列最大容量
            /**
             * 超出最大承载则报错:rejected from java.util.concurrent.ThreadPoolExecutor@27bc2616[Running, pool size = 5, active
             * threads = 5, queued tasks = 3, completed tasks = 0]
             */
            threadPool.execute(() -> {
                System.out.println(Thread.currentThread().getName());
            });
        }
    }
}
```

线程池与银行办理业务的关联:
![avatar](../../static/银行办理业务与线程池.png)

#### 4种拒绝策略:
* AbortPolicy: 最大承载满了后，再有任务进来直接抛异常
* CallerRunsPolicy: 扔给提交任务的那个线程去处理
* DiscardPolicy: 如果队列满了则丢掉提交的任务，不抛异常
* DiscardOldestPolicy: 队列满了尝试去和最早的竞争，不会抛异常

#### 线程池调优: CPU密集型任务及IO密集型业务
* 对于线程池中都是CPU密集型任务，则最大线程数设置为Runtime.getRuntime().availableProcessors()个效率最高，因为可以避免上下文切换
* 对于线程池中都是IO密集型任务，则最大线程数设置为 2* Runtime.getRuntime().availableProcessors()，避免CPU长时间等待IO

##### Fork/Join 线程池
```java
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.ForkJoinTask;
import java.util.concurrent.RecursiveTask;
import java.util.stream.LongStream;

/**
 * Fork/Join 使用流程:
 * <p>
 * 1. 计算类要继承RecursiveTask,覆写compute方法
 * 2.新建一个ForkJoinPool
 * 3. 使用ForkJoinPool的submit方法提交任务
 */
public class ForkJoinDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        test1();
        test2();
        test3();
    }

    // 普通计算
    public static void test1() {
        long startTime = System.currentTimeMillis();
        long sum = 0;
        for (int i = 1; i <= 10_0000_0000; i++) {
            sum += i;
        }
        long endTime = System.currentTimeMillis();
        System.out.println("普通计算得到的sum结果为:" + sum);
        System.out.println("计算用时:" + (endTime - startTime) + "毫秒");
    }

    // fork/join 计算
    public static void test2() throws ExecutionException, InterruptedException {
        long startTime = System.currentTimeMillis();
        ForkJoinPool forkJoinPool = new ForkJoinPool();
        ForkJoinTask<Long> task = new ForkJoinTaskDemo(1, 10_0000_0000, 10000);
        ForkJoinTask<Long> submit = forkJoinPool.submit(task);
        Long result = submit.get();
        long endTime = System.currentTimeMillis();
        System.out.println("fork/join计算结果为:" + result);
        System.out.println("计算用时:" + (endTime - startTime) + "毫秒");
    }

    // stream并行流计算
    public static void test3() {
        long startTime = System.currentTimeMillis();
        Long result = LongStream.rangeClosed(0, 10_0000_0000L).parallel().reduce(0, Long::sum);
        long endTime = System.currentTimeMillis();
        System.out.println("stream并行计算结果为:" + result);
        System.out.println("计算用时:" + (endTime - startTime) + "毫秒");
    }
}

class ForkJoinTaskDemo extends RecursiveTask<Long> {
    private long start;
    private long end;
    private long temp;

    public ForkJoinTaskDemo(long start, long end, long temp) {
        this.start = start;
        this.end = end;
        this.temp = temp;
    }

    @Override
    protected Long compute() {
        // 小于临界值则直接计算
        if (end - start < temp) {
            long sum = 0L;
            for (long i = start; i <= end; i++) {
                sum += i;
            }
            return sum;
        } else {
            // 大于临界值则使用fork/join 用递归方式拆分任务
            long middle = (start + end) / 2;
            ForkJoinTaskDemo task1 = new ForkJoinTaskDemo(start, middle, temp);
            // 拆分任务，把任务压入线程队列
            task1.fork();
            ForkJoinTaskDemo task2 = new ForkJoinTaskDemo(middle + 1, end, temp);
            // 拆分任务，把任务压入线程队列
            task2.fork();
            return task1.join() + task2.join();
        }
    }
}
```
