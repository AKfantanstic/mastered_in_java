# 并发安全容器

## 1.普通的ArrayList在多线程并发环境下去添加元素会有什么问题？
所有的不安全并发都会抛出ConcurrentModificationException
```java
public class ListTest {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        // 多线程下会抛出java.util.ConcurrentModificationException
        for (int i = 1; i < 30; i++) {
            new Thread(() -> {
                list.add(UUID.randomUUID().toString());
                System.out.println(list);
            }).start();
        }
    }
}
```
## 2.如何得到一个线程安全的List？
* 使用Collections.synchronizedList()方法得到一个同步的List
* 使用Vector
* 使用CopyOnWriteArrayList

## 4.HashSet在并发环境下同样会抛异常，如何得到一个线程安全的Set？
* 使用Collections.synchronizedSet()
* 使用CopyOnWriteArraySet

## HashSet底层是怎么实现的？
```java
public class HashSet {
    // 用一个空对象作为常量
    private static final Object PRESENT = new Object();
    
    // 底层使用一个HashMap
    public HashSet() {
        map = new HashMap<>();
    }
    
    // 本质上是用hashMap的key去维护这个set，因为hashMap的key是不重复的。 而present是一个常量
    public boolean add(E e) {
        return map.put(e, PRESENT)==null;
    }
}
```

## 5.HashMap并发环境下同样会抛异常，如何得到一个线程安全的Map？
* 使用Collections.synchronizedMap()
* 使用ConcurrentHashMap

## 3.CopyOnWriteList
源码中思想:改的时候不在原来的上面改，抢到锁后，复制出来改完再set回去

## ConcurrentHashMap

blog.kuangstudy.com 看hashMap相关分析
