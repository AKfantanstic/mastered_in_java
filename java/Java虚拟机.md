## Java 通过引入字节码这种中间表达方式，屏蔽了不同硬件的差异，由 JVM 负责完成从字节码到机器码的转化。

### 1. 代码解释什么是循环引用:
```
class  A {
    public B bb;
}

class  B {
    public A aa;
}

public class TestGC {

    public static  void main(String[] args) {
	A a = new A();
	B b = new B();

	a.bb = b;
	b.aa = a;

	a = null;
	b = null;
    }
}
```
在上面的代码示例中，假设我们有两个类分别是A和B，A类中有一个字段是B类的类型，B类中有一个字段是A类类型，现在分别new一个A类对象和new一个B类对象，
此时引用a指向刚new出来的A类对象，引用b指向刚new出来的B类对象,然后将两个类中的字段互相引用一下，这样即使下面进行a = null和b = null，
但是A类对象仍然被B类对象中的字段引用着，尽管现在A类和B类独享都已经访问不到了，但是引用计数却都不为0.

### 2. 双亲委派模型：
当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父
类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，
只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的
Class），子类加载器才会尝试自己去加载。

>1. 采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载
器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载
器最终得到的都是同样一个 Object 对象。

### 3. 类加载器有哪几种？
1. 启动类加载器(Bootstrap ClassLoader)：负责加载 JAVA_HOME\lib 目录中的
2. 扩展类加载器(Extension ClassLoader)：负责加载 JAVA_HOME\lib\ext 目录中的
3. 应用程序类加载器(Application ClassLoader)：负责加载用户路径（classpath）上的类库
类加载器本身也可以对代码之间进行隔离，例如，应用无法获取启动类加载器（Bootstrap Class-Loader）对象实例，
不同的类加载器也可以起到容器的作用，隔离模块之间不必要的可见性等

### 4.
面试问题如下：
1.Java 类加载过程？
答：Java 类加载需要经历一下 7 个过程：
1. 加载
加载是类加载的第一个过程，在这个阶段，将完成一下三件事情：
* 通过一个类的全限定名获取该类的二进制流。
* 将该二进制流中的静态存储结构转化为方法去运行时数据结构。
* 在内存中生成该类的 Class 对象，作为该类的数据访问入口。
2. 验证
验证的目的是为了确保 Class 文件的字节流中的信息不回危害到虚拟机.在该阶段主要完成以下四钟验证:
* 文件格式验证：验证字节流是否符合 Class 文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型.
* 元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。
* 字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。
* 符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。
3. 准备
准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。
public static int value=123;//在准备阶段value初始值为0 。在初始化阶段才会变为123 。
4. 解析
该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。
5. 初始化
初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 Java 程序代码。
6. 使用
7. 卸载
2.描述一下 JVM 加载 Class 文件的原理机制?
答：Java 语言是一种具有动态性的解释型语言，类（Class）只有被加载到 JVM 后才能运行。当运行指定程序时，JVM 会将编译生成的 .class 文件按照需求和一定的规则加载到内存中，并组织成为一个完整的 Java 应用程序。这个加载过程是由类加载器完成，具体来说，就是由 ClassLoader 和它的子类来实现的。类加载器本身也是一个类，其实质是把类文件从硬盘读取到内存中。
类的加载方式分为隐式加载和显示加载。隐式加载指的是程序在使用 new 等方式创建对象时，会隐式地调用类的加载器把对应的类加载到 JVM 中。显示加载指的是通过直接调用 class.forName() 方法来把所需的类加载到 JVM 中。
任何一个工程项目都是由许多类组成的，当程序启动时，只把需要的类加载到 JVM 中，其他类只有被使用到的时候才会被加载，采用这种方法一方面可以加快加载速度，另一方面可以节约程序运行时对内存的开销。此外，在 Java 语言中，每个类或接口都对应一个 .class 文件，这些文件可以被看成是一个个可以被动态加载的单元，因此当只有部分类被修改时，只需要重新编译变化的类即可，而不需要重新编译所有文件，因此加快了编译速度。
在 Java 语言中，类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类（例如基类）完全加载到 JVM 中，至于其他类，则在需要的时候才加载。
类加载的主要步骤：
* 装载，根据查找路径找到相应的 class 文件，然后导入。
* 链接，链接又可分为 3 个小步：
* 检查，检查待加载的 class 文件的正确性。
* 准备，给类中的静态变量分配存储空间。
* 解析，将符号引用转换为直接引用（这一步可选）
* 初始化。对静态变量和静态代码块执行初始化工作。
3. Java 内存分配。
* 寄存器：我们无法控制。
* 静态域：static定义的静态成员。
* 常量池：编译时被确定并保存在 .class 文件中的（final）常量值和一些文本修饰的符号引用（类和接口的全限定名，字段的名称和描述符，方法和名称和描述符）。
* 非 RAM 存储：硬盘等永久存储空间。
* 堆内存：new 创建的对象和数组，由 Java 虚拟机自动垃圾回收器管理,存取速度慢。
* 栈内存：基本类型的变量和对象的引用变量（堆内存空间的访问地址），速度快，可以共享，但是大小与生存期必须确定，缺乏灵活性。
4.Java 堆的结构是什么样子的？什么是堆中的永久代（Perm Gen space）?
答：JVM 的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在 JVM 启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。
堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些 对象回收掉之前，他们会一直占据堆内存空间。
5.GC 是什么? 为什么要有 GC？
答：GC 是垃圾收集的意思（GabageCollection），内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。
6.简述 Java 垃圾回收机制？
答：在 Java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在 JVM 中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。
7. 如何判断一个对象是否存活？（或者 GC 对象的判定方法）
答：判断一个对象是否存活有两种方法：
1. 引用计数法
所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收.
引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象 A 引用对象 B，对象 B 又引用者对象 A，那么此时 A、B 对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。
2. 可达性算法（引用链法）
该算法的思想是：从一个被称为 GC Roots 的对象开始向下搜索，如果一个对象到 GC Roots 没有任何引用链相连时，则说明此对象不可用。
在 Java 中可以作为 GC Roots 的对象有以下几种：
* 虚拟机栈中引用的对象
* 方法区类静态属性引用的对象
* 方法区常量池引用的对象
* 本地方法栈JNI引用的对象
虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象比不一定会被回收。当一个对象不可达 GC Root 时，这个对象并不会立马被回收，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记.
如果对象在可达性分析中没有与 GC Root 的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法或者已被虚拟机调用过，那么就认为是没必要的。 如果该对象有必要执行 finalize() 方法，那么这个对象将会放在一个称为 F-Queue 的对队列中，虚拟机会触发一个 Finalize() 线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这是因为如果 finalize() 执行缓慢或者发生了死锁，那么就会造成 F-Queue 队列一直等待，造成了内存回收系统的崩溃。GC 对处于 F-Queue 中的对象进行第二次被标记，这时，该对象将被移除” 即将回收” 集合，等待回收。
8.垃圾回收的优点和原理。并考虑 2 种回收机制？
答：Java 语言中一个显著的特点就是引入了垃圾回收机制，使 C++ 程序员最头疼的内存管理的问题迎刃而解，它使得 Java 程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java 中的对象不再有“作用域”的概念，只有对象的引用才有"作用域"。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。
回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。
面试整理
由于篇幅过长的原因，为了不影响大家的阅读效果，文中没有给到所有的答案。我这里以文件的形式整理好了，需要借阅的朋友可以免费领取获得，同时也可以关注一下我以后还会更新更多干货技术。
1. 什么是分布式垃圾回收（DGC）？它是如何工作的？
2. 在 Java 中，对象什么时候可以被垃圾回收？
3. 简述 Java 内存分配与回收策率以及 Minor GC 和 Major GC。
4. JVM 的永久代中会发生垃圾回收么？
5. Java 中垃圾收集的方法有哪些？
6. 什么是类加载器，类加载器有哪些？
7. 类加载器双亲委派模型机制？
8. 垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？
9. Java 中会存在内存泄漏吗，请简单描述。
10. System.gc() 和 Runtime.gc() 会做什么事情？

### 5. 四种引用:
强引用：不回收。
软引用：内存不够就回收。
弱引用：一定回收。
虚引用：一定回收，get出来就是null，引用形同虚设，主要和引用队列联合使用，在finalize之前会被放到引用队列中。
与 GC Roots 没有引用关系的：引用不可达，一定回收。

### 6.jvm优化java代码时都做了什么？
jvm对代码执行的优化分为两部分:运行时优化 和 即时编译器优化(JIT)
      
运行时优化：比如说锁机制（如偏斜锁）、内存分配机制（如 TLAB）等     
即时编译器优化： 是指将热点代码以方法为单位转换成机器码，直接运行在底层硬件之上

### 7. JVM的运行参数怎么指定？
* 如果用IDEA等开发工具，来启动运行项目，那么要调试JDK就方便多了，只需要将参数值设置到VM options中即可。  
* 如果在Linux上运行jar包，则需要用下面命令运行:
```
java -jar -XX:MetaspaceSize=128m
-XX:MaxMetaspaceSize=128m
-Xms1024m -Xmx1024m -Xmn256m -Xss256k
-XX:SurvivorRatio=8
-XX:+UseConcMarkSweepGC xxx.jar
```

### 8.Java 常见的垃圾收集器有哪些？
* G1:两种GC模式，Young GC和Mixed GC，两种都是完全Stop The World的
