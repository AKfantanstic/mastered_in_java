## Java 通过引入字节码这种中间表达方式，屏蔽了不同硬件的差异，由 JVM 负责完成从字节码到机器码的转化。

### 1. 代码解释什么是循环引用:
```
class  A {
    public B bb;
}

class  B {
    public A aa;
}

public class TestGC {

    public static  void main(String[] args) {
	A a = new A();
	B b = new B();

	a.bb = b;
	b.aa = a;

	a = null;
	b = null;
    }
}
```
在上面的代码示例中，假设我们有两个类分别是A和B，A类中有一个字段是B类的类型，B类中有一个字段是A类类型，现在分别new一个A类对象和new一个B类对象，
此时引用a指向刚new出来的A类对象，引用b指向刚new出来的B类对象,然后将两个类中的字段互相引用一下，这样即使下面进行a = null和b = null，
但是A类对象仍然被B类对象中的字段引用着，尽管现在A类和B类独享都已经访问不到了，但是引用计数却都不为0.

### 2. 双亲委派模型：
当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父
类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，
只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的
Class），子类加载器才会尝试自己去加载。

>1. 采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载
器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载
器最终得到的都是同样一个 Object 对象。

### 3. 类加载器有哪几种？
1. 启动类加载器(Bootstrap ClassLoader)：负责加载 JAVA_HOME\lib 目录中的
2. 扩展类加载器(Extension ClassLoader)：负责加载 JAVA_HOME\lib\ext 目录中的
3. 应用程序类加载器(Application ClassLoader)：负责加载用户路径（classpath）上的类库
类加载器本身也可以对代码之间进行隔离，例如，应用无法获取启动类加载器（Bootstrap Class-Loader）对象实例，
不同的类加载器也可以起到容器的作用，隔离模块之间不必要的可见性等

### 4.请介绍类加载过程，然后还说下什么是双亲委派模型？
类加载需要经历一下 7 个过程：  
加载: 加载是类加载的第一个过程，在这个阶段，将完成一下三件事情：  
* 通过一个类的全限定名获取该类的二进制流。
* 将该二进制流中的静态存储结构转化为方法去运行时数据结构。
* 在内存中生成该类的 Class 对象，作为该类的数据访问入口。

验证: 验证的目的是为了确保 Class 文件的字节流中的信息不回危害到虚拟机.在该阶段主要完成以下四钟验证:  
* 文件格式验证：验证字节流是否符合 Class 文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型.
* 元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。
* 字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。
* 符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。

准备: 准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。
public static int value=123;//在准备阶段value初始值为0 。在初始化阶段才会变为123 。  

解析: 该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。  

初始化: 初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 Java 程序代码。

使用
卸载

补充: (所有的类运行时解析之后，再次运行时还会重复解析吗？简单说，如果没有被jit编译，是的)

2.描述一下 JVM 加载 Class 文件的原理机制?
答：Java 语言是一种具有动态性的解释型语言，类（Class）只有被加载到 JVM 后才能运行。当运行指定程序时，JVM 会将编译生成的 .class 文件按照需求和一定的规则加载到内存中，并组织成为一个完整的 Java 应用程序。这个加载过程是由类加载器完成，具体来说，就是由 ClassLoader 和它的子类来实现的。类加载器本身也是一个类，其实质是把类文件从硬盘读取到内存中。
类的加载方式分为隐式加载和显示加载。隐式加载指的是程序在使用 new 等方式创建对象时，会隐式地调用类的加载器把对应的类加载到 JVM 中。显示加载指的是通过直接调用 class.forName() 方法来把所需的类加载到 JVM 中。
任何一个工程项目都是由许多类组成的，当程序启动时，只把需要的类加载到 JVM 中，其他类只有被使用到的时候才会被加载，采用这种方法一方面可以加快加载速度，另一方面可以节约程序运行时对内存的开销。此外，在 Java 语言中，每个类或接口都对应一个 .class 文件，这些文件可以被看成是一个个可以被动态加载的单元，因此当只有部分类被修改时，只需要重新编译变化的类即可，而不需要重新编译所有文件，因此加快了编译速度。
在 Java 语言中，类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类（例如基类）完全加载到 JVM 中，至于其他类，则在需要的时候才加载。
类加载的主要步骤：
* 装载，根据查找路径找到相应的 class 文件，然后导入。
* 链接，链接又可分为 3 个小步：
* 检查，检查待加载的 class 文件的正确性。
* 准备，给类中的静态变量分配存储空间。
* 解析，将符号引用转换为直接引用（这一步可选）
* 初始化。对静态变量和静态代码块执行初始化工作。
3. Java 内存分配。
* 寄存器：我们无法控制。
* 静态域：static定义的静态成员。
* 常量池：编译时被确定并保存在 .class 文件中的（final）常量值和一些文本修饰的符号引用（类和接口的全限定名，字段的名称和描述符，方法和名称和描述符）。
* 非 RAM 存储：硬盘等永久存储空间。
* 堆内存：new 创建的对象和数组，由 Java 虚拟机自动垃圾回收器管理,存取速度慢。
* 栈内存：基本类型的变量和对象的引用变量（堆内存空间的访问地址），速度快，可以共享，但是大小与生存期必须确定，缺乏灵活性。
4.Java 堆的结构是什么样子的？什么是堆中的永久代（Perm Gen space）?
答：JVM 的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在 JVM 启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。
堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些 对象回收掉之前，他们会一直占据堆内存空间。
5.GC 是什么? 为什么要有 GC？
答：GC 是垃圾收集的意思（GabageCollection），内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。
6.简述 Java 垃圾回收机制？
答：在 Java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在 JVM 中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。
7. 如何判断一个对象是否存活？（或者 GC 对象的判定方法）
答：判断一个对象是否存活有两种方法：
1. 引用计数法
所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收.
引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象 A 引用对象 B，对象 B 又引用者对象 A，那么此时 A、B 对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。
2. 可达性算法（引用链法）
该算法的思想是：从一个被称为 GC Roots 的对象开始向下搜索，如果一个对象到 GC Roots 没有任何引用链相连时，则说明此对象不可用。
在 Java 中可以作为 GC Roots 的对象有以下几种：
* 虚拟机栈中引用的对象
* 方法区类静态属性引用的对象
* 方法区常量池引用的对象
* 本地方法栈JNI引用的对象
虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象比不一定会被回收。当一个对象不可达 GC Root 时，这个对象并不会立马被回收，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记.
如果对象在可达性分析中没有与 GC Root 的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法或者已被虚拟机调用过，那么就认为是没必要的。 如果该对象有必要执行 finalize() 方法，那么这个对象将会放在一个称为 F-Queue 的对队列中，虚拟机会触发一个 Finalize() 线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这是因为如果 finalize() 执行缓慢或者发生了死锁，那么就会造成 F-Queue 队列一直等待，造成了内存回收系统的崩溃。GC 对处于 F-Queue 中的对象进行第二次被标记，这时，该对象将被移除” 即将回收” 集合，等待回收。
8.垃圾回收的优点和原理。并考虑 2 种回收机制？
答：Java 语言中一个显著的特点就是引入了垃圾回收机制，使 C++ 程序员最头疼的内存管理的问题迎刃而解，它使得 Java 程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java 中的对象不再有“作用域”的概念，只有对象的引用才有"作用域"。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。
回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。

面试题整理(***用已经学会的知识去回答，检验学习的成果***)  

由于篇幅过长的原因，为了不影响大家的阅读效果，文中没有给到所有的答案。我这里以文件的形式整理好了，需要借阅的朋友可以免费领取获得，同时也可以关注一下我以后还会更新更多干货技术。
1. 什么是分布式垃圾回收（DGC）？它是如何工作的？
2. 在 Java 中，对象什么时候可以被垃圾回收？
3. 简述 Java 内存分配与回收策率以及 Minor GC 和 Major GC。
4. JVM 的永久代中会发生垃圾回收么？
5. Java 中垃圾收集的方法有哪些？
6. 什么是类加载器，类加载器有哪些？
7. 类加载器双亲委派模型机制？
8. 垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？
9. Java 中会存在内存泄漏吗，请简单描述。
10. System.gc() 和 Runtime.gc() 会做什么事情？

### 5. 四种引用:
强引用：不回收。
软引用：内存不够就回收。
弱引用：一定回收。
虚引用：一定回收，get出来就是null，引用形同虚设，主要和引用队列联合使用，在finalize之前会被放到引用队列中。
与 GC Roots 没有引用关系的：引用不可达，一定回收。

### 6.JVM 优化 Java 代码时都做了什么？
jvm对代码执行的优化分为两部分:运行时优化 和 即时编译器优化(JIT)
      
运行时优化：比如说锁机制（如偏斜锁）、内存分配机制（如 TLAB）等     
即时编译器优化： 是指将热点代码以方法为单位转换成机器码，直接运行在底层硬件之上

### 7. JVM的运行参数怎么指定？
* 如果用IDEA等开发工具，来启动运行项目，那么要调试JDK就方便多了，只需要将参数值设置到VM options中即可。  
* 如果在Linux上运行jar包，则需要用下面命令运行:
```
java -jar -XX:MetaspaceSize=128m
-XX:MaxMetaspaceSize=128m
-Xms1024m -Xmx1024m -Xmn256m -Xss256k
-XX:SurvivorRatio=8
-XX:+UseConcMarkSweepGC xxx.jar
```

### 8.Java 常见的垃圾收集器有哪些？
* SerialGC、Parallel GC、 CMS、 G1
* G1:两种GC模式，Young GC和Mixed GC，两种都是完全Stop The World的

### 9.新生代的垃圾收集过程是怎样的？
* 新生代主要采用复制算法,过程：当Minor GC 开始时，将Eden区和from-survivor区存活的对象年龄加1，然后分别复制到to-survivor区，然后将eden区和from-survivor区清空，
最后将from-survivor和to-survivor交换，此时的状态是eden区为空，from-survivor区有对象，to-survivor区为空。
每次Minor GC 后各区都保持这个状态。

* 关于Eden、两个Survivor的细节。
1、大部分对象创建都是在Eden的，除了个别大对象外。
2、Minor GC开始前，to-survivor是空的，from-survivor是有对象的。
3、Minor GC后，Eden的存活对象都copy到to-survivor中，from-survivor的存活对象也复制to-survivor中。其中所有对象的年龄+1
4、from-survivor清空，成为新的to-survivor，带有对象的to-survivor变成新的from-survivor。重复回到步骤2

### 10.新生代的对象的内存分配过程是怎样的？
我们知道普通的对象会被分配在 TLAB(Thread Local Allocation Buffer) 上；如果对象较大，JVM 会试图直接分配在 Eden 其他位置上；如果对象太大，
完全无法在新生代找到足够长的连续空闲空间，JVM 就会直接分配到老年代。大对象具体是多大，取决于使用的gc是哪种，
cms是PretenureSizeThreshold，G1是region大小的一半

### 11.谈谈 JVM 内存区域的划分，哪些区域可能发生 OutOfMemoryError？

### 12.热点代码的调用次数在 JVM 不同模式下分别是多少？
* 运行时，JVM 会通过类加载器（Class-Loader）加载字节码，解释或者编译执行。主流 Java 版本中，如 JDK 8
实际是解释和编译混合的一种模式，即所谓的混合模式（-Xmixed）。通常运行在 server 模式的 JVM，会进行上万次调用
以收集足够的信息进行高效的编译，client 模式这个门限是 1500 次。Oracle Hotspot JVM 内置了两个不同的 JIT 
compiler，C1 对应前面说的 client 模式，适用于对于启动速度敏感的应用，比如普通 Java 桌面应用；C2 对应 
server 模式，它的优化是为长时间运行的服务器端应用设计的。默认是采用所谓的分层编译（TieredCompilation）。

### 13. Java 是解释执行”，这句话正确吗？
* 这个说法不太准确。大部分代码是通过 JVM 内部的解释器来将字节码转换成机器码来解释执行的。但是不同厂商提供的 JVM 都提供了
JIT编译器(Just In Time,即时编译器),JIT 能在运行时将热点代码直接编译成机器码，这种情况就属于编译执行了。
* ***扩展1***：写个程序直接执行字节码就是解释执行。写个程序运行时把字节码动态翻译成机器码就是jit。写个程序把java源代码直接翻译为机器码就是aot。造个CPU直接执行字节码，字节码就是机器码。
* ***扩展2***：解释执行和编译执行的区别，可以类比一下，解释执行是同声传译，编译执行是放录音


### 14. JVM运行参数及说明:
* 指定“-Xint”，就是告诉 JVM 只进行解释执行，不对代码进行编译，这种模式抛弃了 JIT 可能带来的性能优势。毕竟解释器（interpreter）是逐条读入，逐条解释运行的。
* “-Xcomp”参数，这是告诉 JVM 关闭解释器，不要进行解释执行，或者叫作最大优化级别.-Xcomp”会导致 JVM 启动变慢非常多，同时有些 JIT 编译器优化方式，比如分支预测，
如果不进行 profiling，往往并不能进行有效优化。

### 15. JIT为什么能提高运行速度？
* JIT 这种基于运行时统计分析热点代码，并对热点代码进行编辑成机器码的这种设计，是因为绝大多数的程序都表现为“小部分的热点代码的运行耗费了大多数的资源”

### 16. Hotspot虚拟机是如何判定为热点代码的？
* Hotspot 热点探测使用的方法是调用计数器和回边计数器，虚拟机为每个代码块，每个方法，建立计数器，统计执行次数，超过一定阀值，
就视为热点代码，这种实现较为复杂，但是结果更为严谨

### 17.JVM中哪些区域可能发生OutOfMemoryError？ 

### 18.什么是准确式内存管理？
HotSpot就是基于准确式内存管理。准确式内存管理是指虚拟机可以知道内存中某个位 置的数据具体是什么类型。
譬如内存中有一个32bit的整数123456，虚拟机将有能力分辨出它到底是一 个指向了123456的内存地址的引用类型还是一个数值为123456的整数，
准确分辨出哪些内存是引用类 型，这也是在垃圾收集时准确判断堆上的数据是否还可能被使用的前提。
由于使用了准确式内存管 理，Exact VM可以抛弃掉以前Classic VM基于句柄（Handle）的对象查找方式
（原因是垃圾收集后对 象将可能会被移动位置，如果地址为123456的对象移动到654321，
在没有明确信息表明内存中哪些数 据是引用类型的前提下，那虚拟机肯定是不敢把内存中所有为123456的值改成654321的，
所以要使用 句柄来保持引用值的稳定），这样每次定位对象都少了一次间接查找的开销，显著提升执行性能
HotSpot虚拟机的热点代码探测能力可以通过执行计数器 找出最具有编译价值的代码，
然后通知即时编译器以方法为单位进行编译。如果一个方法被频繁调 用，或方法中有效循环次数很多，
将会分别触发标准即时编译和栈上替换编译（On-Stack Replacement，OSR）行为。

### 19.三大虚拟机名称？
* HotSpot
* JRockit
* IBM公司的IBM J9

### 20.运行时数据区结构？
运行时数据区: 方法区和堆为所有线程共享的数据区  
程序计数器，虚拟机栈，本地方法栈为线程私有的数据区  